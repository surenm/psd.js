// Generated by CoffeeScript 1.3.3

/*!
PSD.js - A Photoshop file parser for browsers and NodeJS
https://github.com/meltingice/psd.js

MIT LICENSE
Copyright (c) 2011 Ryan LeFevre
 
Permission is hereby granted, free of charge, to any person obtaining a copy of this 
software and associated documentation files (the "Software"), to deal in the Software 
without restriction, including without limitation the rights to use, copy, modify, merge, 
publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons 
to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or 
substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING 
BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/


(function() {
  /*
  Copyright Â© 2008 Fair Oaks Labs, Inc.
  All rights reserved.


  Redistribution and use in source and binary forms, with or without modification, are
  permitted provided that the following conditions are met:

      * Redistributions of source code must retain the above copyright notice, this list
        of conditions and the following disclaimer.

      * Redistributions in binary form must reproduce the above copyright notice, this
        list of conditions and the following disclaimer in the documentation and/or other
        materials provided with the distribution.

      * Neither the name of Fair Oaks Labs, Inc. nor the names of its contributors may be
        used to endorse or promote products derived from this software without specific
        prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
  THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// Utility object:  Encode/Decode C-style binary primitives to/from octet arrays
function JSPack()
{
  // Module-level (private) variables
  var el,  bBE = false, m = this;


  // Raw byte arrays
  m._DeArray = function (a, p, l)
  {
    return [a.slice(p,p+l)];
  };
  m._EnArray = function (a, p, l, v)
  {
    for (var i = 0; i < l; a[p+i] = v[i]?v[i]:0, i++);
  };

  // ASCII characters
  m._DeChar = function (a, p)
  {
    return String.fromCharCode(a[p]);
  };
  m._EnChar = function (a, p, v)
  {
    a[p] = v.charCodeAt(0);
  };

  // Little-endian (un)signed N-byte integers
  m._DeInt = function (a, p)
  {
    var lsb = bBE?(el.len-1):0, nsb = bBE?-1:1, stop = lsb+nsb*el.len, rv, i, f;
    for (rv = 0, i = lsb, f = 1; i != stop; rv+=(a[p+i]*f), i+=nsb, f*=256);
    if (el.bSigned && (rv & Math.pow(2, el.len*8-1))) { rv -= Math.pow(2, el.len*8); }
    return rv;
  };
  m._EnInt = function (a, p, v)
  {
    var lsb = bBE?(el.len-1):0, nsb = bBE?-1:1, stop = lsb+nsb*el.len, i;
    v = (v<el.min)?el.min:(v>el.max)?el.max:v;
    for (i = lsb; i != stop; a[p+i]=v&0xff, i+=nsb, v>>=8);
  };

  // ASCII character strings
  m._DeString = function (a, p, l)
  {
    for (var rv = new Array(l), i = 0; i < l; rv[i] = String.fromCharCode(a[p+i]), i++);
    return rv.join('');
  };
  m._EnString = function (a, p, l, v)
  {
    for (var t, i = 0; i < l; a[p+i] = (t=v.charCodeAt(i))?t:0, i++);
  };

  // Little-endian N-bit IEEE 754 floating point
  m._De754 = function (a, p)
  {
    var s, e, m, i, d, nBits, mLen, eLen, eBias, eMax;
    mLen = el.mLen, eLen = el.len*8-el.mLen-1, eMax = (1<<eLen)-1, eBias = eMax>>1;

    i = bBE?0:(el.len-1); d = bBE?1:-1; s = a[p+i]; i+=d; nBits = -7;
    for (e = s&((1<<(-nBits))-1), s>>=(-nBits), nBits += eLen; nBits > 0; e=e*256+a[p+i], i+=d, nBits-=8);
    for (m = e&((1<<(-nBits))-1), e>>=(-nBits), nBits += mLen; nBits > 0; m=m*256+a[p+i], i+=d, nBits-=8);

    switch (e)
    {
      case 0:
        // Zero, or denormalized number
        e = 1-eBias;
        break;
      case eMax:
        // NaN, or +/-Infinity
        return m?NaN:((s?-1:1)*Infinity);
      default:
        // Normalized number
        m = m + Math.pow(2, mLen);
        e = e - eBias;
        break;
    }
    return (s?-1:1) * m * Math.pow(2, e-mLen);
  };
  m._En754 = function (a, p, v)
  {
    var s, e, m, i, d, c, mLen, eLen, eBias, eMax;
    mLen = el.mLen, eLen = el.len*8-el.mLen-1, eMax = (1<<eLen)-1, eBias = eMax>>1;

    s = v<0?1:0;
    v = Math.abs(v);
    if (isNaN(v) || (v == Infinity))
    {
      m = isNaN(v)?1:0;
      e = eMax;
    }
    else
    {
      e = Math.floor(Math.log(v)/Math.LN2);     // Calculate log2 of the value
      if (v*(c = Math.pow(2, -e)) < 1) { e--; c*=2; }   // Math.log() isn't 100% reliable

      // Round by adding 1/2 the significand's LSD
      if (e+eBias >= 1) { v += el.rt/c; }     // Normalized:  mLen significand digits
      else { v += el.rt*Math.pow(2, 1-eBias); }     // Denormalized:  <= mLen significand digits
      if (v*c >= 2) { e++; c/=2; }        // Rounding can increment the exponent

      if (e+eBias >= eMax)
      {
        // Overflow
        m = 0;
        e = eMax;
      }
      else if (e+eBias >= 1)
      {
        // Normalized - term order matters, as Math.pow(2, 52-e) and v*Math.pow(2, 52) can overflow
        m = (v*c-1)*Math.pow(2, mLen);
        e = e + eBias;
      }
      else
      {
        // Denormalized - also catches the '0' case, somewhat by chance
        m = v*Math.pow(2, eBias-1)*Math.pow(2, mLen);
        e = 0;
      }
    }

    for (i = bBE?(el.len-1):0, d=bBE?-1:1; mLen >= 8; a[p+i]=m&0xff, i+=d, m/=256, mLen-=8);
    for (e=(e<<mLen)|m, eLen+=mLen; eLen > 0; a[p+i]=e&0xff, i+=d, e/=256, eLen-=8);
    a[p+i-d] |= s*128;
  };


  // Class data
  m._sPattern = '(\\d+)?([AxcbBhHsfdiIlL])';
  m._lenLut = {'A':1, 'x':1, 'c':1, 'b':1, 'B':1, 'h':2, 'H':2, 's':1, 'f':4, 'd':8, 'i':4, 'I':4, 'l':4, 'L':4};
  m._elLut  = { 'A': {en:m._EnArray, de:m._DeArray},
        's': {en:m._EnString, de:m._DeString},
        'c': {en:m._EnChar, de:m._DeChar},
        'b': {en:m._EnInt, de:m._DeInt, len:1, bSigned:true, min:-Math.pow(2, 7), max:Math.pow(2, 7)-1},
        'B': {en:m._EnInt, de:m._DeInt, len:1, bSigned:false, min:0, max:Math.pow(2, 8)-1},
        'h': {en:m._EnInt, de:m._DeInt, len:2, bSigned:true, min:-Math.pow(2, 15), max:Math.pow(2, 15)-1},
        'H': {en:m._EnInt, de:m._DeInt, len:2, bSigned:false, min:0, max:Math.pow(2, 16)-1},
        'i': {en:m._EnInt, de:m._DeInt, len:4, bSigned:true, min:-Math.pow(2, 31), max:Math.pow(2, 31)-1},
        'I': {en:m._EnInt, de:m._DeInt, len:4, bSigned:false, min:0, max:Math.pow(2, 32)-1},
        'l': {en:m._EnInt, de:m._DeInt, len:4, bSigned:true, min:-Math.pow(2, 31), max:Math.pow(2, 31)-1},
        'L': {en:m._EnInt, de:m._DeInt, len:4, bSigned:false, min:0, max:Math.pow(2, 32)-1},
        'f': {en:m._En754, de:m._De754, len:4, mLen:23, rt:Math.pow(2, -24)-Math.pow(2, -77)},
        'd': {en:m._En754, de:m._De754, len:8, mLen:52, rt:0}};

  // Unpack a series of n elements of size s from array a at offset p with fxn
  m._UnpackSeries = function (n, s, a, p)
  {
    for (var fxn = el.de, rv = [], i = 0; i < n; rv.push(fxn(a, p+i*s)), i++);
    return rv;
  };

  // Pack a series of n elements of size s from array v at offset i to array a at offset p with fxn
  m._PackSeries = function (n, s, a, p, v, i)
  {
    for (var fxn = el.en, o = 0; o < n; fxn(a, p+o*s, v[i+o]), o++);
  };

  // Unpack the octet array a, beginning at offset p, according to the fmt string
  m.Unpack = function (fmt, a, p)
  {
    // Set the private bBE flag based on the format string - assume big-endianness
    bBE = (fmt.charAt(0) != '<');

    p = p?p:0;
    var re = new RegExp(this._sPattern, 'g'), m, n, s, rv = [];
    while (m = re.exec(fmt))
    {
      n = ((m[1]==undefined)||(m[1]==''))?1:parseInt(m[1]);
      s = this._lenLut[m[2]];
      if ((p + n*s) > a.length)
      {
        return undefined;
      }
      switch (m[2])
      {
        case 'A': case 's':
          rv.push(this._elLut[m[2]].de(a, p, n));
          break;
        case 'c': case 'b': case 'B': case 'h': case 'H':
        case 'i': case 'I': case 'l': case 'L': case 'f': case 'd':
          el = this._elLut[m[2]];
          rv.push(this._UnpackSeries(n, s, a, p));
          break;
      }
      p += n*s;
    }
    return Array.prototype.concat.apply([], rv);
  };

  // Pack the supplied values into the octet array a, beginning at offset p, according to the fmt string
  m.PackTo = function (fmt, a, p, values)
  {
    // Set the private bBE flag based on the format string - assume big-endianness
    bBE = (fmt.charAt(0) != '<');

    var re = new RegExp(this._sPattern, 'g'), m, n, s, i = 0, j;
    while (m = re.exec(fmt))
    {
      n = ((m[1]==undefined)||(m[1]==''))?1:parseInt(m[1]);
      s = this._lenLut[m[2]];
      if ((p + n*s) > a.length)
      {
        return false;
      }
      switch (m[2])
      {
        case 'A': case 's':
          if ((i + 1) > values.length) { return false; }
          this._elLut[m[2]].en(a, p, n, values[i]);
          i += 1;
          break;
        case 'c': case 'b': case 'B': case 'h': case 'H':
        case 'i': case 'I': case 'l': case 'L': case 'f': case 'd':
          el = this._elLut[m[2]];
          if ((i + n) > values.length) { return false; }
          this._PackSeries(n, s, a, p, values, i);
          i += n;
          break;
        case 'x':
          for (j = 0; j < n; j++) { a[p+j] = 0; }
          break;
      }
      p += n*s;
    }
    return a;
  };

  // Pack the supplied values into a new octet array, according to the fmt string
  m.Pack = function (fmt, values)
  {
    return this.PackTo(fmt, new Array(this.CalcLength(fmt)), 0, values);
  };

  // Determine the number of bytes represented by the format string
  m.CalcLength = function (fmt)
  {
    var re = new RegExp(this._sPattern, 'g'), m, sum = 0;
    while (m = re.exec(fmt))
    {
      sum += (((m[1]==undefined)||(m[1]==''))?1:parseInt(m[1])) * this._lenLut[m[2]];
    }
    return sum;
  };
};

var jspack = new JSPack(); ;

  /*
  END DEPENDENCIES
  */

  var EngineDataParser, Log, PSD, PSDBlackWhite, PSDBrightnessContrast, PSDChannelImage, PSDColor, PSDColorBalance, PSDConstants, PSDCurves, PSDDescriptor, PSDDropDownLayerEffect, PSDEffectsDescriptor, PSDEffectsInfo, PSDExposure, PSDFile, PSDGradient, PSDHeader, PSDHueSaturation, PSDImage, PSDInvert, PSDLayer, PSDLayerEffect, PSDLayerEffectCommonStateInfo, PSDLayerMask, PSDLevels, PSDPattern, PSDPhotoFilter, PSDPosterize, PSDResource, PSDSelectiveColor, PSDSolidColor, PSDThreshold, PSDTypeTool, PSDVibrance, Parser, Root, Util, assert, fs,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  assert = (function(assert) {
    if (typeof exports !== "undefined" && exports !== null) {
      return require('assert');
    }
    assert = function(test) {
      if (test !== true) {
        throw "Assertion error";
      }
    };
    assert.equal = function(actual, expected) {
      if (actual !== expected) {
        throw "Assertion error";
      }
    };
    return assert;
  })(assert);

  PSDConstants = (function() {

    function PSDConstants() {}

    PSDConstants.CONSTANTS = {
      '591487860': 'actionReference',
      '591490663': 'angleUnit',
      '591620178': 'channelReference',
      '591621187': 'colorChannel',
      '591621221': 'classExport',
      '591621189': 'classElement',
      '591621190': 'classFormat',
      '591621193': 'classImport',
      '591621197': 'classMode',
      '591621234': 'classColor',
      '591621203': 'classStringFormat',
      '591621204': 'classTextImport',
      '591615045': 'classTextExport',
      '591684434': 'documentReference',
      '591752274': 'elementReference',
      '591950678': 'classHueSatHueSatV2',
      '592014674': 'imageReference',
      '594112067': 'integerChannel',
      '592145526': 'kelvinCustomWhitePoint',
      '592208756': 'locationReference',
      '592342629': 'noneUnit',
      '592472179': 'phosphorsCustomPhosphors',
      '592474723': 'percentUnit',
      '592475218': 'pathReference',
      '592476268': 'pixelsUnit',
      '592604276': 'distanceUnit',
      '592606060': 'densityUnit',
      '592671811': 'stringClassFormat',
      '592671846': 'stringFSS',
      '594769000': 'stringChannel',
      '592671817': 'stringInteger',
      '592671853': 'stringCompensation',
      '592738637': 'typeClassModeOrClassMode',
      '825639540': '16BitsPerPixel',
      '843215987': '2BitsPerPixel',
      '858931828': '32BitsPerPixel',
      '876770419': '4BitsPerPixel',
      '892350512': '5000',
      '892678192': '5500',
      '909455408': '6500',
      '926040940': '72Color',
      '926040909': 'multi72Color',
      '926040915': 'single72Color',
      '926041933': 'multi72Gray',
      '926041970': '72Gray',
      '926041939': 'single72Gray',
      '926232624': '7500',
      '959655984': '9300',
      '1092624416': 'a',
      '1096958320': 'aboutApp',
      '1096971116': 'absolute',
      '1096963180': 'airbrushTool',
      '1094866028': 'artBrushTool',
      '1097032517': 'accentedEdges',
      '1094936684': 'alphaChannelOptionsClass',
      '1094936686': 'alphaChannelOptions',
      '1094937714': 'absColorimetric',
      '1097036371': 'useAccurateScreens',
      '1097036868': 'actionData',
      '1097036910': 'action',
      '1097036880': 'actualPixels',
      '1097089652': 'ADSBottoms',
      '1097089864': 'ADSCentersH',
      '1097089878': 'ADSCentersV',
      '1097098272': 'add',
      '1097098324': 'addTo',
      '1097091186': 'ADSHorizontal',
      '1097099852': 'adjustmentLayer',
      '1097099855': 'adjustmentOptions',
      '1097099891': 'adjustment',
      '1097092198': 'ADSLefts',
      '1097092723': 'addNoise',
      '1097093228': 'useAdditionalPlugins',
      '1097101428': 'adaptive',
      '1097093735': 'ADSRights',
      '1094996852': 'alignDistributeSelector',
      '1097094256': 'ADSTops',
      '1097094770': 'ADSVertical',
      '1097605152': 'allEnum',
      '1097623328': 'alignmentType',
      '1097623396': 'aligned',
      '1097623406': 'align',
      '1634494835': 'alias',
      '1097623923': '3DAntiAlias',
      '1097624608': 'all',
      '1097624645': 'allExcept',
      '1097625667': 'alphaChannels',
      '1097618540': 'allToolOptions',
      '1097687618': 'ambientBrightness',
      '1097687619': 'ambientColor',
      '1634551913': 'amountHigh',
      '1634552943': 'amountLow',
      '1634553188': 'amountMedium',
      '1097682286': 'amplitudeMin',
      '1097682296': 'amplitudeMax',
      '1097690740': 'amount',
      '1097753448': 'anchor',
      '1097745266': 'antiAliasCrisp',
      '1097754417': 'angle1',
      '1097754418': 'angle2',
      '1097754419': 'angle3',
      '1097754420': 'angle4',
      '1097754476': 'angle',
      '1097754451': 'angledStrokes',
      '1097746537': 'antiAliasHigh',
      '1097747567': 'antiAliasLow',
      '1097747812': 'antiAliasMedium',
      '1097756271': 'antiAliasNone',
      '1097756276': 'antiAliasType',
      '1097749357': 'antiAliasSmooth',
      '1097749364': 'antiAliasStrong',
      '1097757761': 'antiAlias',
      '1097759008': 'any',
      '1097886793': 'applyImageEnum',
      '1097886841': 'apply',
      '1097887845': 'append',
      '1097887817': 'applyImageEvent',
      '1097887826': 'appleRGB',
      '1097998368': 'area',
      '1098015347': 'airbrushEraser',
      '1098018371': 'aroundCenter',
      '1098018407': 'arrange',
      '1098011500': 'areaSelector',
      '1098063904': 'as',
      '1095975753': 'ASCII',
      '1095984500': 'actionSet',
      '1098083104': 'ask',
      '1098083159': 'askWhenOpening',
      '1098084980': 'assert',
      '1098085187': 'assumedCMYK',
      '1098085191': 'assumedGray',
      '1098085199': 'assumeOptions',
      '1098085200': 'assumedProfile',
      '1098085202': 'assumedRGB',
      '1095988345': 'applyStyle',
      '1098129440': 'at',
      '1098140530': 'autoKern',
      '1098150515': 'autoErase',
      '1098143088': 'autoUpdateFiles',
      '1098204015': 'autoContrast',
      '1098216559': 'auto',
      '1098410355': 'axis',
      '1109401632': 'b',
      '1113678699': 'back',
      '1113681495': 'blackAndWhite',
      '1113809507': 'bicubic',
      '1113811779': 'backgroundColor',
      '1113811815': 'background',
      '1113811788': 'backgroundLayer',
      '1113811831': 'backwardEnum',
      '1111765280': 'bitDepth1',
      '1111765556': 'bitDepth24',
      '1111766048': 'bitDepth4',
      '1111767072': 'bitDepth8',
      '1111839596': 'bevelEmbossStyle',
      '1111839603': 'bevelEmbossStampStyle',
      '1111839813': 'matteTechnique',
      '1114066504': 'bigNudgeH',
      '1114074706': 'beginRamp',
      '1114074707': 'beginSustain',
      '1114066518': 'bigNudgeV',
      '1114140260': 'behind',
      '1114316832': 'book',
      '1114325868': 'bookColor',
      '1114382368': 'blue',
      '1114391148': 'blueBlackPoint',
      '1114399554': 'blackBody',
      '1114399555': 'blackClip',
      '1114399559': 'blackGenerationType',
      '1114399561': 'blackIntensity',
      '1114399595': 'black',
      '1114399564': 'blackLevel',
      '1114399598': 'blackGeneration',
      '1114399776': 'bleed',
      '1651271276': 'createLayersFromLayerFX',
      '1114392429': 'blueGamma',
      '1114401568': 'blockEraser',
      '1114401651': 'blacks',
      '1114402403': 'balance',
      '1114402404': 'blendRange',
      '1114402381': 'blendMode',
      '1114402418': 'bilinear',
      '1114403360': 'blurEvent',
      '1114403405': 'blurMethod',
      '1114403409': 'blurQuality',
      '1114403616': 'blues',
      '1114403700': 'blast',
      '1114403907': 'builtInShapeCurve',
      '1114395756': 'blurTool',
      '1114403950': 'builtin',
      '1114403920': 'builtinProfile',
      '1651275122': 'blur',
      '1114396520': 'blueWhitePoint',
      '1114396704': 'blueX',
      '1114396960': 'blueY',
      '1114468417': 'bumpAmplitude',
      '1114468419': 'bumpChannel',
      '1112363078': 'bMPFormat',
      '1114534521': 'binary',
      '1651470188': 'boolean',
      '1114658664': 'beepWhenDone',
      '1114792535': 'brushWideBlurry',
      '1114793074': 'border',
      '1114784850': 'brushDarkRough',
      '1114793044': 'borderThickness',
      '1114793795': 'brightnessEvent',
      '1114793832': 'brightness',
      '1114795592': 'burnInH',
      '1114795597': 'burnInM',
      '1114795603': 'burnInS',
      '1114796865': 'brushesAppend',
      '1114796900': 'brushesLoad',
      '1114796868': 'brushDetail',
      '1114796902': 'brushesDelete',
      '1114796904': 'brush',
      '1114796876': 'brushLightRough',
      '1114788717': 'brushSimple',
      '1114796878': 'brushesNew',
      '1114796879': 'brushesOptions',
      '1114788720': 'brushSparkle',
      '1114796882': 'brushesReset',
      '1114796883': 'brushSize',
      '1114796884': 'brushType',
      '1114796918': 'brushesSave',
      '1114796887': 'brushWideSharp',
      '1114788972': 'burnInTool',
      '1114860654': 'baselineShift',
      '1114853996': 'basRelief',
      '1114862624': 'best',
      '1114923846': 'batchFromDroplet',
      '1114923880': 'batch',
      '1114915952': 'bitDepth',
      '1114926413': 'bitmapMode',
      '1114926448': 'bitmap',
      '1114926669': 'buttonMode',
      '1114926957': 'bottom',
      '1114928237': 'bottomEnum',
      '1651928132': 'bevelDirection',
      '1651928147': 'bevelStyle',
      '1651928148': 'bevelTechnique',
      '1115120672': 'backward',
      '1115234336': 'by',
      '1115253870': 'byline',
      '1115253844': 'bylineTitle',
      '1115255887': 'byteOrder',
      '1665147742': 'inherits',
      '1667330160': 'application',
      '1665233527': 'arrowhead',
      '1128428142': 'colorBurn',
      '1130588240': 'cachePrefs',
      '1128555623': 'colorDodge',
      '1130786678': 'constructionFOV',
      '1130905965': 'charcoalAmount',
      '1130914667': 'checkerboardSize',
      '1130914636': 'checkerboardLarge',
      '1130914637': 'checkerboardMedium',
      '1130914638': 'checkerboardNone',
      '1130914643': 'checkerboardSmall',
      '1130907224': 'chromeFX',
      '1130916929': 'chalkArea',
      '1130916931': 'chalkCharcoal',
      '1130909048': 'channelMatrix',
      '1130917449': 'channelsInterleaved',
      '1130917484': 'channel',
      '1130917453': 'channelMixer',
      '1130917454': 'channelName',
      '1130917455': 'channelOptions',
      '1130917456': 'channelsPaletteOptions',
      '1130917491': 'channels',
      '1130918465': 'charcoalArea',
      '1130918499': 'charcoal',
      '1130918509': 'chrome',
      '1128821584': 'historyPrefsClass',
      '1130984569': 'city',
      '1131113844': 'chokeMatte',
      '1131176306': 'clearEnum',
      '1131176562': 'calibrationBars',
      '1131176812': 'calculation',
      '1131176814': 'calculationType',
      '1131177075': 'clouds',
      '1131177330': 'clearEvent',
      '1131171175': 'colorManagement',
      '1131171188': 'colorMatch',
      '1131179351': 'columnWidth',
      '1131179603': 'cloneSource',
      '1131171443': 'colorNoise',
      '1131180130': 'clipboard',
      '1131180102': 'clippingPathFlatness',
      '1131180135': 'clippingPathInfo',
      '1131180105': 'clippingPathIndex',
      '1131180143': 'clippingInfo',
      '1131180112': 'clippingPathEPS',
      '1131171956': 'clippingPath',
      '1131180576': 'color',
      '1131180609': 'clearAmount',
      '1131180610': 'colorBalance',
      '1131180611': 'colorCorrection',
      '1131180615': 'clearGuides',
      '1131180648': 'colorChannels',
      '1131180616': 'colorHalftone',
      '1131180617': 'colorIndicates',
      '1131180651': 'colorPickerPrefsClass',
      '1131180620': 'colorsList',
      '1131180653': 'colorimetric',
      '1131180624': 'colorPalette',
      '1131180658': 'colorPickerPrefs',
      '1131180626': 'colorRange',
      '1131180659': 'colors',
      '1131180627': 'colorSpace',
      '1131180660': 'colorStop',
      '1131180628': 'colorTable',
      '1131180665': 'colorStopType',
      '1131180666': 'colorize',
      '1131180832': 'close',
      '1131180865': 'closeAll',
      '1131172717': 'colorSampler',
      '1131180912': 'closedSubpath',
      '1131172730': 'cellSize',
      '1131172972': 'cloneStampTool',
      '1131242571': 'commandKey',
      '1131245156': 'command',
      '1131245678': 'compensation',
      '1131245682': 'compression',
      '1131245683': 'composite',
      '1129141062': 'CMYK64',
      '1129142595': 'CMYKColorClass',
      '1129142597': 'CMYKSetupEngine',
      '1129142603': 'CMYK',
      '1129142605': 'CMYKColorMode',
      '1129142611': 'CMYKSetup',
      '1131307894': 'concavity',
      '1131308142': 'sourceModeType',
      '1131308148': 'condition',
      '1131311952': 'constrainProportions',
      '1131311988': 'constant',
      '1131312160': 'count',
      '1131312227': 'contract',
      '1131312195': 'centerCropMarks',
      '1131312197': 'contourEdge',
      '1131312231': 'contiguous',
      '1131312238': 'continue',
      '1131312206': 'countryName',
      '1131312242': 'center',
      '1131312249': 'continuity',
      '1131312707': 'convertToCMYK',
      '1131312711': 'convertToGray',
      '1131312716': 'convertToLab',
      '1131312717': 'convertMode',
      '1131312754': 'convert',
      '1131312722': 'convertToRGB',
      '1131312723': 'canvasSize',
      '1668247673': 'copyEvent',
      '1131431512': 'copyEffects',
      '1131442766': 'copyrightNotice',
      '1131435084': 'copyToLayer',
      '1131443310': 'caption',
      '1131443287': 'captionWriter',
      '1131444512': 'copy',
      '1131444557': 'copyMerged',
      '1131444594': 'copyright',
      '1131569986': 'crackBrightness',
      '1131569988': 'crackDepth',
      '1131569997': 'correctionMethod',
      '1131570003': 'crackSpacing',
      '1131570292': 'credit',
      '1129465666': 'CIERGB',
      '1131572803': 'cornerCropMarks',
      '1131572808': 'currentHistoryState',
      '1131572812': 'currentLight',
      '1131572852': 'current',
      '1131572820': 'currentToolOptions',
      '1131573104': 'crop',
      '1131565172': 'curvePoint',
      '1131573612': 'craquelure',
      '1131573836': 'currentLayer',
      '1131574048': 'cross',
      '1131574084': 'coarseDots',
      '1131574120': 'crosshatch',
      '1131574091': 'cursorKind',
      '1131574131': 'crossover',
      '1131574132': 'crystallize',
      '1131574340': 'createDroplet',
      '1131574345': 'createInterpolation',
      '1131574816': 'curve',
      '1131574849': 'curvesAdjustment',
      '1131574854': 'curveFile',
      '1131574899': 'curves',
      '1131635556': 'cascade',
      '1668506988': 'selectionClass',
      '1131639840': 'customEnum',
      '1131639878': 'customForced',
      '1131639916': 'customPaletteClass',
      '1131639917': 'custom',
      '1131639885': 'customMatte',
      '1131639888': 'customPalette',
      '1131639891': 'customStops',
      '1131639895': 'customWhitePoint',
      '1131683872': 'cutout',
      '1131702130': 'category',
      '1131704902': 'centeredFrame',
      '1131697228': 'cutToLayer',
      '1668641824': 'cut',
      '1132031520': 'cyan',
      '1132031603': 'cyans',
      '1147366766': 'document',
      '1145262880': 'DCS',
      '1147430728': 'dodgeH',
      '1147430733': 'dodgeM',
      '1147430739': 'dodgeS',
      '1147425900': 'dodgeTool',
      '1147561540': 'diffusionDither',
      '1147563588': 'diffusionDitherEnum',
      '1147563600': 'definePattern',
      '1147563636': 'definition',
      '1147564611': 'differenceClouds',
      '1147564647': 'defringe',
      '1147564654': 'difference',
      '1147564832': 'diffuse',
      '1147564871': 'diffuseGlow',
      '1147564877': 'diffuseMode',
      '1147564910': 'diffusion',
      '1684825720': 'disableLayerFX',
      '1147958304': 'delete',
      '1148022372': 'diamond',
      '1148023922': 'diameter',
      '1148087619': 'dynamicColorSliders',
      '1148089204': 'density',
      '1148089458': 'deInterlace',
      '1148150601': 'documentID',
      '1685026146': 'floatType',
      '1148208240': 'deepDepth',
      '1148218467': 'duplicate',
      '1148220520': 'depth',
      '1148346743': 'draw',
      '1148347202': 'directionBalance',
      '1148347252': 'direction',
      '1148348020': 'draft',
      '1148349216': 'dark',
      '1148349257': 'darkIntensity',
      '1148349294': 'darken',
      '1148349263': 'darkenOnly',
      '1148349267': 'darkStrokes',
      '1148343144': 'dropShadow',
      '1148352834': 'dryBrush',
      '1148414028': 'dashedLines',
      '1148415075': 'deselect',
      '1148415094': 'dissolve',
      '1148416099': 'despeckle',
      '1148416067': 'displayCursorsPreferences',
      '1148416070': 'displaceFile',
      '1148416108': 'displace',
      '1148416077': 'displacementMap',
      '1148416080': 'displayPrefs',
      '1148417090': 'destBlackMin',
      '1148417132': 'destBlackMax',
      '1148417101': 'destinationMode',
      '1148417134': 'distance',
      '1148417138': 'distort',
      '1148417107': 'dustAndScratches',
      '1148417140': 'desaturate',
      '1148417111': 'destWhiteMin',
      '1148461088': 'datum',
      '1148470130': 'dateCreated',
      '1148471107': 'dotGainCurves',
      '1148471150': 'dotGain',
      '1148479553': 'ditherAmount',
      '1148479586': 'better',
      '1148479590': 'faster',
      '1148479600': 'ditherPreserve',
      '1148479601': 'ditherQuality',
      '1148479602': 'dither',
      '1148480544': 'detail',
      '1148481056': 'duotone',
      '1148481097': 'duotoneInk',
      '1148481101': 'duotoneMode',
      '1148481104': 'transferPoint',
      '1148482336': 'dots',
      '1700946540': 'bevelEmboss',
      '1161974816': 'eBUITU',
      '1162038617': 'CMYKColorEnum',
      '1164207904': 'edge',
      '1164207938': 'edgeBrightness',
      '1164207942': 'edgeFidelity',
      '1164207945': 'edgeIntensity',
      '1164207955': 'edgeSimplicity',
      '1164207956': 'edgeThickness',
      '1164207959': 'edgeWidth',
      '1164338787': 'effect',
      '1164404802': '8BitsPerPixel',
      '1164733765': 'eliminateEvenFields',
      '1164733806': 'element',
      '1164733775': 'eliminateOddFields',
      '1164734579': 'ellipse',
      '1164796483': 'embedCMYK',
      '1164796487': 'embedGray',
      '1164796492': 'embedLab',
      '1164796496': 'embedProfiles',
      '1164796498': 'embedRGB',
      '1164796531': 'emboss',
      '1164799044': 'emulsionDown',
      '1701732706': 'enabled',
      '1164862308': 'encoding',
      '1164862496': 'end',
      '1164862529': 'endArrowhead',
      '1164862546': 'endRamp',
      '1164862547': 'endSustain',
      '1164863342': 'engine',
      '1701737837': 'enumerated',
      '1162892099': 'EPSPICTPreview',
      '1162892103': 'EPSGenericFormat',
      '1162892112': 'EPSPreview',
      '1162892116': 'EPSTIFFPreview',
      '1162964084': 'extendedQuality',
      '1165061242': 'equalize',
      '1165128523': 'eraserKind',
      '1165128532': 'eraseToHistory',
      '1165120620': 'eraserTool',
      '1165517672': 'exchange',
      '1165517648': 'exactPoints',
      '1165517684': 'exact',
      '1165520963': 'exportClipboard',
      '1165521006': 'expand',
      '1165521010': 'export',
      '1165521011': 'exposure',
      '1165522020': 'extend',
      '1165521988': 'extrudeDepth',
      '1165521990': 'extrudeSolidFace',
      '1165521997': 'extrudeMaskIncomplete',
      '1165522030': 'extension',
      '1165522001': 'extensionsQuery',
      '1165522034': 'extrude',
      '1165522002': 'extrudeRandom',
      '1165522003': 'extrudeSize',
      '1165522004': 'extrudeType',
      '1165575280': 'eyeDropperSampleType',
      '1165575282': 'eyeDropperSample',
      '1180787813': 'fade',
      '1180856908': 'fiberLength',
      '1180922656': 'focus',
      '1180922912': 'facet',
      '1180980256': 'fadeTo',
      '1180988499': 'fadeoutSteps',
      '1181314149': 'file',
      '1181314130': 'fileReference',
      '1181491232': 'fill',
      '1181500003': 'fillBack',
      '1181500268': 'fillColor',
      '1181500270': 'fillContents',
      '1181500274': 'fileCreator',
      '1181508722': 'folders',
      '1181508896': 'fileEnum',
      '1181501042': 'fillFore',
      '1181501806': 'fileInfo',
      '1181510000': 'flip',
      '1181510724': 'fullDocument',
      '1181502820': 'fillMode',
      '1181510983': 'filmGrain',
      '1181503092': 'fillNeutral',
      '1181503334': 'falloff',
      '1181512259': 'flareCenter',
      '1181504365': 'fillSame',
      '1181512528': 'flashPixFormat',
      '1181504336': 'fileSavePrefs',
      '1181504374': 'fileSavePrefsClass',
      '1181504378': 'fullSize',
      '1181512777': 'flattenImage',
      '1181512814': 'flatness',
      '1181512818': 'filter',
      '1181512820': 'flatten',
      '1181504633': 'fileType',
      '1181578272': 'format',
      '1181639499': 'functionKey',
      '1181639749': 'findEdges',
      '1181631604': 'fineDots',
      '1181640562': 'fingerpainting',
      '1181643844': 'fontDesignAxes',
      '1181643854': 'fontName',
      '1181643859': 'fontStyleName',
      '1181643860': 'fontTechnology',
      '1181643862': 'fontDesignAxesVectors',
      '1181901635': 'forcedColors',
      '1181894252': 'frameFill',
      '1181894232': 'frameFX',
      '1181902659': 'foregroundColor',
      '1181902668': 'foregroundLevel',
      '1181902701': 'fragment',
      '1181895012': 'firstIdle',
      '1181904194': 'fromBuiltin',
      '1181904205': 'fromMode',
      '1181904215': 'frameWidth',
      '1181904500': 'front',
      '1181904749': 'from',
      '1181905262': 'frequency',
      '1181905763': 'fresco',
      '1181905780': 'first',
      '1181897842': 'freeTransform',
      '1181906802': 'forwardEnum',
      '1718838636': 'selection',
      '1179874412': 'frameStyle',
      '1179935603': 'freeTransformCenterState',
      '1182034034': 'feather',
      '1182027630': 'fitOnScreen',
      '1182229536': 'forward',
      '1182286701': 'FPXCompress',
      '1182288464': 'FPXCompressLossyJPEG',
      '1182289519': 'FPXCompressNone',
      '1182290284': 'FPXQuality',
      '1182290810': 'FPXSize',
      '1182291575': 'FPXView',
      '1182428787': 'fuzziness',
      '1734436716': 'globalLightingAngle',
      '1734503489': 'globalAngle',
      '1195594272': 'GCR',
      '1197744160': 'good',
      '1197761907': 'guides',
      '1197754226': 'guideGridColor',
      '1197754195': 'guideGridStyle',
      '1197755760': 'gradientMapClass',
      '1197756530': 'guidesPrefs',
      '1197765443': 'guidesColor',
      '1197765491': 'guidesCustomColor',
      '1197765459': 'guidesStyle',
      '1734702180': 'get',
      '1195784249': 'GIF89aExport',
      '1195786829': 'GIFUseBestMatch',
      '1195787078': 'GIFColorFileColors',
      '1195787081': 'GIFRequiredColorSpaceIndexed',
      '1195787084': 'GIFColorLimit',
      '1195787091': 'GIFRequiredColorSpaceType',
      '1195787092': 'GIFColorFileColorTable',
      '1195787587': 'GIFExportCaption',
      '1195787890': 'GIFFormat',
      '1195788622': 'GIFRowOrderInterlaced',
      '1195788628': 'GIFRowOrderType',
      '1195789641': 'GIFMaskChannelIndex',
      '1195789651': 'GIFColorFileMicrosoftPalette',
      '1195789654': 'GIFMaskChannelInverted',
      '1195789897': 'GIFRowOrderNormal',
      '1195790401': 'GIFPaletteAdaptive',
      '1195790405': 'GIFPaletteExact',
      '1195790406': 'GIFPaletteFile',
      '1195790412': 'GIFPaletteType',
      '1195790415': 'GIFPaletteOther',
      '1195790419': 'GIFPaletteSystem',
      '1195790420': 'GIFColorFileType',
      '1195790919': 'GIFRequiredColorSpaceRGB',
      '1195791426': 'GIFTransparentIndexBlue',
      '1195791427': 'GIFTransparentColor',
      '1195791431': 'GIFTransparentIndexGreen',
      '1195791442': 'GIFTransparentIndexRed',
      '1198285379': 'globalClass',
      '1198285391': 'globalObject',
      '1198288755': 'gloss',
      '1198289696': 'glass',
      '1198290753': 'glowAmount',
      '1198290757': 'glowingEdges',
      '1735161683': 'innerGlowSource',
      '1198290772': 'glowTechnique',
      '1198353696': 'gamma',
      '1198355543': 'gamutWarning',
      '1198420560': 'generalPreferences',
      '1198666040': 'gray18',
      '1198666290': 'gray22',
      '1198667056': 'gray50',
      '1198678372': 'gradient',
      '1198678352': 'graphicPen',
      '1198670440': 'grayBehavior',
      '1198670702': 'grainContrasty',
      '1198679107': 'gridColor',
      '1198679110': 'gradientForm',
      '1198679117': 'gridMajor',
      '1198679150': 'gradientClassEvent',
      '1198679155': 'gridCustomColor',
      '1198679123': 'gridStyle',
      '1198679156': 'gridUnits',
      '1198679124': 'gradientType',
      '1198671468': 'gradientFill',
      '1198673264': 'gradientMapEvent',
      '1198681632': 'grain',
      '1198681666': 'greenBlackPoint',
      '1198681667': 'grainClumped',
      '1198681668': 'grainyDots',
      '1198681669': 'grainEnlarged',
      '1198681671': 'greenGamma',
      '1198681672': 'grainHorizontal',
      '1198681682': 'grainRegular',
      '1198681715': 'graininess',
      '1198681716': 'grainType',
      '1198681686': 'grainVertical',
      '1198681687': 'greenWhitePoint',
      '1198681688': 'greenX',
      '1198681689': 'greenY',
      '1198681975': 'grow',
      '1198682144': 'graphics',
      '1198682188': 'groupEvent',
      '1198682979': 'grayscale',
      '1198674790': 'grainSoft',
      '1198674800': 'grainSpeckle',
      '1198674802': 'grainSprinkles',
      '1198674804': 'grainStippled',
      '1198675052': 'gradientTool',
      '1198683223': 'groutWidth',
      '1198683504': 'group',
      '1198684448': 'gray',
      '1198684515': 'grayScale',
      '1198684531': 'grayscaleMode',
      '1198684504': 'gray16',
      '1198747168': 'gaussianDistribution',
      '1198747202': 'gaussianBlur',
      '1198814295': 'gutterWidth',
      '1198875719': 'guidesGridPreferences',
      '1210064928': 'hue',
      '1212306540': 'historyBrushTool',
      '1214521376': 'hide',
      '1214529900': 'hideAll',
      '1214540910': 'headline',
      '1214542368': 'header',
      '1214534508': 'hideSelection',
      '1212437590': 'HDTV',
      '1214736416': 'highQuality',
      '1214736449': 'highlightArea',
      '1214736492': 'highlights',
      '1214736460': 'highlightLevels',
      '1214736464': 'highPass',
      '1214736467': 'highlightStrength',
      '1214736500': 'height',
      '1751608387': 'highlightColor',
      '1751608397': 'highlightMode',
      '1751608399': 'highlightOpacity',
      '1214867304': 'high',
      '1215063622': 'halftoneFile',
      '1215063664': 'halftoneSpec',
      '1215063635': 'halftoneScreen',
      '1215058810': 'halftoneSize',
      '1215456332': 'hardLight',
      '1215456366': 'hardness',
      '1215461964': 'horizontalLocation',
      '1215461998': 'horizontal',
      '1215461967': 'horizontalOnly',
      '1215461971': 'horizontalScale',
      '1213416003': 'HSBColorClass',
      '1213416044': 'HSBColorEnum',
      '1213416013': 'HSBColorMode',
      '1213418563': 'HSLColor',
      '1215517523': 'historyStateSource',
      '1215517556': 'historyStates',
      '1215525938': 'hueSatAdjustmentV2',
      '1213428801': 'hueSatAdjustment',
      '1215525954': 'historyBrushSource',
      '1215525991': 'histogram',
      '1215525966': 'hostName',
      '1215525967': 'historyPaletteOptions',
      '1215525968': 'historyPreferences',
      '1213428850': 'hueSaturation',
      '1215525971': 'historyState',
      '1215525974': 'hostVersion',
      '1215526009': 'history',
      '1215723808': 'heavy',
      '1229081936': 'IBMPC',
      '1229144648': 'interfaceColorBlue32',
      '1229144652': 'interfaceColorBlue2',
      '1229144864': 'ICC',
      '1229144901': 'ICCEngine',
      '1229144948': 'ICCSetupName',
      '1229145928': 'interfaceColorGreen32',
      '1229145932': 'interfaceColorGreen2',
      '1229155442': 'interfaceColor',
      '1231253024': 'icon',
      '1229148744': 'interfaceColorRed32',
      '1229148748': 'interfaceColorRed2',
      '1231318117': 'idle',
      '1231318644': 'ID',
      '1231312461': 'idleVM',
      '1231515250': 'ignore',
      '1229411186': 'innerGlowSourceType',
      '1231844176': 'illustratorPathsExport',
      '1231906592': 'image',
      '1231906626': 'imageBalance',
      '1231906640': 'imageCachePreferences',
      '1231906643': 'imageSize',
      '1231908978': 'import',
      '1231908979': 'impressionist',
      '1231953952': 'in',
      '1231962694': 'interfaceButtonUpFill',
      '1231971395': 'indexedColorMode',
      '1231971436': 'indexedColor',
      '1231971920': 'infoPaletteOptions',
      '1231971924': 'infoPaletteToggleSamplers',
      '1231973187': 'inkColors',
      '1231973199': 'inkOutlines',
      '1231973235': 'inks',
      '1231973204': 'inkTransfer',
      '1231973746': 'inputMapRange',
      '1231974514': 'inputRange',
      '1231974516': 'input',
      '1231974978': 'innerBevel',
      '1231975268': 'inside',
      '1231975238': 'insetFrame',
      '1231975490': 'interfaceBlack',
      '1231975523': 'interfaceIconFillSelected',
      '1231975491': 'interlaceCreateType',
      '1231975524': 'interfaceBorder',
      '1231975525': 'intent',
      '1231975493': 'interlaceEliminateType',
      '1231975494': 'interfaceIconFillDimmed',
      '1231975496': 'interfaceBevelHighlight',
      '1231975497': 'interfaceIconFillActive',
      '1231975531': 'interfaceButtonDarkShadow',
      '1231975533': 'interfaceIconFrameActive',
      '1231975501': 'interpolationMethod',
      '1231975534': 'intensity',
      '1231975536': 'interpolationType',
      '1231975504': 'interfacePaletteFill',
      '1231975538': 'interfaceIconFrameDimmed',
      '1231975506': 'interfaceRed',
      '1231975507': 'interfaceIconFrameSelected',
      '1231975540': 'interfaceButtonDownFill',
      '1231975508': 'interfaceToolTipBackground',
      '1231975542': 'interfaceBevelShadow',
      '1231975511': 'interfaceWhite',
      '1231976013': 'invertMask',
      '1231976050': 'invert',
      '1231976051': 'inverse',
      '1231976019': 'invertSource2',
      '1231976020': 'invertTexture',
      '1232226156': 'innerGlow',
      '1232229224': 'innerShadow',
      '1232290930': 'isDirty',
      '1230258791': 'interfaceTransparencyBackground',
      '1230259815': 'interfaceTransparencyForeground',
      '1232366921': 'itemIndex',
      '1230263380': 'interfaceToolTipText',
      '1246774599': 'JPEG',
      '1246774609': 'JPEGQuality',
      '1248883823': 'jumpto',
      '1249080385': 'justifyAll',
      '1249080390': 'justifyFull',
      '1265399406': 'kelvin',
      '1265525792': 'kind',
      '1263563375': 'keepProfile',
      '1265790567': 'kerning',
      '1266246224': 'keyboardPreferences',
      '1266251620': 'keywords',
      '1281450528': 'lab',
      '1818322796': 'localLightingAngle',
      '1281453156': 'localLightingAltitude',
      '1281508166': 'lab48',
      '1281508204': 'labColor',
      '1281508173': 'labColorMode',
      '1281518707': 'labels',
      '1281584210': 'localRange',
      '1281586286': 'location',
      '1279541836': 'lightDirBottomLeft',
      '1279541842': 'lightDirBottomRight',
      '1279541876': 'lightDirBottom',
      '1279544422': 'lightDirLeft',
      '1281650279': 'leading',
      '1279545959': 'lightDirRight',
      '1279546444': 'lightDirTopLeft',
      '1279546480': 'lightDirTop',
      '1279546450': 'lightDirTopRight',
      '1281713780': 'left',
      '1281713784': 'layerEffects',
      '1281782816': 'leftPlugin',
      '1818654838': 'layerFXVisible',
      '1281836146': 'lightDark',
      '1281845316': 'lightDirection',
      '1281845317': 'lightingEffects',
      '1281845319': 'lightenGrout',
      '1281845321': 'lightIntensity',
      '1281845358': 'lighten',
      '1281845327': 'lightOmni',
      '1281845328': 'lightPosition',
      '1281845331': 'lightSource',
      '1281845364': 'lightness',
      '1281845332': 'lightType',
      '1281848352': 'light',
      '1281848386': 'lightBlue',
      '1281848391': 'lightGray',
      '1281848402': 'lightRed',
      '1281977957': 'line',
      '1282240099': 'luminance',
      '1282240115': 'luminosity',
      '1282285600': 'lineClass',
      '1282303091': 'landscape',
      '1282303820': 'longLines',
      '1282303827': 'longStrokes',
      '1282303860': 'length',
      '1282304800': 'link',
      '1282304868': 'linked',
      '1282304844': 'linkedLayerIDs',
      '1282306592': 'linear',
      '1282306848': 'lens',
      '1282306886': 'lensFlare',
      '1282369312': 'log',
      '1819242087': 'integer',
      '1282373408': 'low',
      '1280328268': 'lightPosBottomLeft',
      '1280328306': 'lightPosBottomRight',
      '1280328308': 'lightPosBottom',
      '1280330854': 'lightPosLeft',
      '1280332391': 'lightPosRight',
      '1280332876': 'lightPosTopLeft',
      '1280332912': 'lightPosTop',
      '1280332882': 'lightPosTopRight',
      '1282565920': 'large',
      '1282634784': 'last',
      '1282634822': 'lastFilter',
      '1282634836': 'lastTransform',
      '1280601709': 'LUTAnimation',
      '1282829344': 'level',
      '1282829377': 'levelsAdjustment',
      '1282829378': 'levelBased',
      '1282829427': 'levels',
      '1282875424': 'lowQuality',
      '1282884467': 'lowerCase',
      '1282896416': 'lower',
      '1283027488': 'layer',
      '1283027529': 'layerID',
      '1283027534': 'layerName',
      '1283027535': 'layerOptions',
      '1283027536': 'layersPaletteOptions',
      '1283027571': 'layers',
      '1280988995': 'LZWCompression',
      '1296131184': 'masterAdaptive',
      '1298361939': 'macintoshSystem',
      '1298361972': 'macintosh',
      '1298354286': 'macPaintFormat',
      '1298355304': 'macThumbnail',
      '1298407456': 'mode',
      '1298424940': 'middle',
      '1298417522': 'modeGray',
      '1298426221': 'medium',
      '1298427168': 'mediumQuality',
      '1298427202': 'mediumBlue',
      '1298427204': 'mediumDots',
      '1298427212': 'mediumLines',
      '1298427219': 'mediumStrokes',
      '1298427424': 'median',
      '1298428014': 'midpoint',
      '1298420295': 'modeRGB',
      '1298429004': 'midtoneLevels',
      '1298429038': 'midtones',
      '1298558838': 'manipulationFOV',
      '1298621296': 'magicPoint',
      '1298613618': 'magicEraserTool',
      '1298624116': 'magenta',
      '1298866208': 'make',
      '1298880115': 'makeVisible',
      '1298953283': 'multichannelMode',
      '1298953320': 'multichannel',
      '1298953328': 'multiply',
      '1299018320': 'memoryPreferences',
      '1299018325': 'memoryUsagePercent',
      '1299062816': 'menuItemClass',
      '1299080040': 'monochromatic',
      '1299073396': 'menuItemType',
      '1299082528': 'minimum',
      '1299084398': 'monotone',
      '1299084371': 'monitorSetup',
      '1299148393': 'monitor',
      '1836021349': 'move',
      '1299202668': 'mapBlack',
      '1297114482': 'masterPerceptual',
      '1299212115': 'mappingShape',
      '1299213927': 'mapping',
      '1299343171': 'mergeChannels',
      '1299343204': 'merged',
      '1299343205': 'merge',
      '1299343180': 'mergeLayers',
      '1299343190': 'mergeVisible',
      '1299407648': 'mosaic',
      '1299407700': 'mosaicPlugin',
      '1297311084': 'masterSelective',
      '1299408741': 'message',
      '1299409696': 'mask',
      '1299409729': 'maskedAreas',
      '1299409737': 'maskIndicator',
      '1299410243': 'mismatchCMYK',
      '1299410247': 'mismatchGray',
      '1299410258': 'mismatchRGB',
      '1297313908': 'mergeSpotChannel',
      '1299474532': 'method',
      '1299476034': 'motionBlur',
      '1299477100': 'material',
      '1299477112': 'matrix',
      '1299477571': 'matteColor',
      '1299600416': 'moveTo',
      '1299737888': 'maximum',
      '1299737965': 'maximumEnum',
      '1299737939': 'maximumStates',
      '1299870830': 'mezzotint',
      '1299870804': 'mezzotintType',
      '1310728224': 'no',
      '1313039208': 'numberOfCacheLevels',
      '1313041741': 'multiNoCompositePS',
      '1313041776': 'noCompositePS',
      '1313041747': 'singleNoCompositePS',
      '1313303671': 'neonGlow',
      '1315402870': 'negative',
      '1315663392': 'nikon',
      '1315663409': 'nikon105',
      '1315774496': 'name',
      '1315791427': 'numberOfChildren',
      '1315791428': 'numberOfDocuments',
      '1315791431': 'numberOfGenerators',
      '1315791436': 'numberOfLayers',
      '1315791439': 'numberOfChannels',
      '1315791440': 'numberOfPaths',
      '1315791474': 'number',
      '1315791442': 'numberOfRipples',
      '1315791443': 'numberOfSiblings',
      '1315850605': 'nonImageData',
      '1315851374': 'nonLinear',
      '1315925605': 'none',
      '1315926885': 'noise',
      '1316121964': 'normal',
      '1316121936': 'normalPath',
      '1316123508': 'nearestNeighbor',
      '1316177778': 'netscapeGray',
      '1316251257': 'notify',
      '1316245618': 'notePaper',
      '1316254316': 'neutrals',
      '1314149187': 'NTSC',
      '1853189228': 'null',
      '1316382544': 'navigatorPaletteOptions',
      '1316429856': 'new',
      '1316443767': 'newView',
      '1316516896': 'next',
      '1868720672': 'objectReference',
      '1331849827': 'object',
      '1331849806': 'objectName',
      '1331851856': 'overridePrinter',
      '1331916370': 'oceanRipple',
      '1332110880': 'off',
      '1332114292': 'offset',
      '1332617248': 'on',
      '1332626036': '1BitPerPixel',
      '1332629350': 'onOff',
      '1332765027': 'opacityClass',
      '1332756851': 'openAs',
      '1332765556': 'opacity',
      '1332768288': 'open',
      '1332769901': 'optimized',
      '1332896878': 'ordinal',
      '1332897608': 'originalHeader',
      '1332889452': 'outerGlow',
      '1332897620': 'originalTransmissionReference',
      '1332899431': 'orange',
      '1332899444': 'orientation',
      '1330852384': 'OS2',
      '1333020274': 'outFromCenter',
      '1333028931': 'otherCursors',
      '1333022566': 'outOfGamut',
      '1333031028': 'output',
      '1333031490': 'outerBevel',
      '1333031780': 'outside',
      '1333097504': 'stampOut',
      '1333097542': 'outsetFrame',
      '1333162563': 'overprintColors',
      '1333162596': 'overrideSave',
      '1333162604': 'overlay',
      '1333162575': 'overrideOpen',
      '1345466946': 'P22EBU',
      '1348551533': 'pathComponent',
      '1348552280': 'pasteEffects',
      '1885434740': 'paste',
      '1348564072': 'path',
      '1348555884': 'patternStampTool',
      '1348627279': 'playbackOptions',
      '1348621420': 'paintbrushTool',
      '1348692803': 'pickCMYK',
      '1348692807': 'pickGray',
      '1348692808': 'pickHSB',
      '1348692809': 'pickerID',
      '1348692811': 'pickerKindType',
      '1348692812': 'pickLab',
      '1348692815': 'pickOptions',
      '1348692850': 'pickerKind',
      '1348692818': 'pickRGB',
      '1348686956': 'pencilTool',
      '1346651719': 'PDFGenericFormat',
      '1348825699': 'perceptual',
      '1346847076': 'PNGFilterAdaptive',
      '1346847094': 'PNGFilterAverage',
      '1346849089': 'PNGInterlaceAdam7',
      '1346849102': 'PNGInterlaceNone',
      '1346849108': 'PNGInterlaceType',
      '1348947565': 'pageNumber',
      '1346850415': 'PNGFilterNone',
      '1348948035': 'pagePosCentered',
      '1348948083': 'pagePosition',
      '1346850932': 'PNGFilterPaeth',
      '1346851682': 'PNGFilterSub',
      '1348948852': 'pageSetup',
      '1348949068': 'pagePosTopLeft',
      '1346852208': 'PNGFilterUp',
      '1349010481': 'photoshopDCSFormat',
      '1349010482': 'photoshopDCS2Format',
      '1349022576': 'phosphors',
      '1349022770': 'photoshop20Format',
      '1349022771': 'photoshop35Format',
      '1349022819': 'photocopy',
      '1349022789': 'photoshopEPSFormat',
      '1349022827': 'photoshopPicker',
      '1349022800': 'photoshopPDFFormat',
      '1346978630': 'PICTFileFormat',
      '1346978642': 'PICTResourceFormat',
      '1349280544': 'placeEvent',
      '1349280613': 'placeEnum',
      '1349272930': 'pillowEmboss',
      '1349281606': 'pluginFolder',
      '1349281646': 'polygon',
      '1349281616': 'pluginPicker',
      '1349281619': 'pluginsScratchDiskPreferences',
      '1349284384': 'polar',
      '1349284434': 'polarToRect',
      '1349276515': 'palSecam',
      '1349284724': 'plaster',
      '1349284695': 'plasticWrap',
      '1349284896': 'palette',
      '1349284966': 'platform',
      '1349284934': 'paletteFile',
      '1349284939': 'paletteKnife',
      '1349284940': 'savePaletteLocations',
      '1349286176': 'play',
      '1347252326': 'pageFormat',
      '1347252339': 'printSettings',
      '1349411688': 'pinch',
      '1349411692': 'pencilEraser',
      '1349411922': 'pondRipples',
      '1347307366': 'PNGFilter',
      '1347307334': 'PNGFormat',
      '1349415968': 'paint',
      '1349415985': 'point16',
      '1349416034': 'paintbrushEraser',
      '1349416003': 'paintingCursors',
      '1349416004': 'paintDaubs',
      '1349416044': 'pointillize',
      '1349416020': 'paintType',
      '1349408371': 'panaVision',
      '1349546562': 'paperBrightness',
      '1347441530': 'pixelPaintSize',
      '1349665356': 'preciseMatte',
      '1349673760': 'precise',
      '1349674051': 'predefinedColors',
      '1349674562': 'preferBuiltin',
      '1349674573': 'profileMismatch',
      '1349674610': 'preferences',
      '1349674579': 'profileSetup',
      '1349674580': 'profileToProfile',
      '1349674853': 'purge',
      '1349674825': 'purgeItem',
      '1349675373': 'primaries',
      '1349667182': 'parentIndex',
      '1349676617': 'printingInksSetup',
      '1349668461': 'parentName',
      '1349676627': 'printSize',
      '1349676660': 'print',
      '1349677088': 'purple',
      '1349677170': 'property',
      '1349677856': 'pressure',
      '1349677889': 'preserveAdditional',
      '1349677900': 'preserveLuminosity',
      '1349677936': 'perspective',
      '1349677908': 'preserveTransparency',
      '1349678658': 'previewBlack',
      '1349678659': 'previewCMYKEnum',
      '1349678662': 'previewFullSize',
      '1349678665': 'previewIcon',
      '1349678667': 'previewCMYK',
      '1349678669': 'previewMacThumbnail',
      '1349678670': 'previewCMY',
      '1349678671': 'previewOff',
      '1349678673': 'previewsQuery',
      '1349678707': 'previous',
      '1349678675': 'provinceState',
      '1349678708': 'previewCMYKType',
      '1349678711': 'preview',
      '1349678679': 'previewWinThumbnail',
      '1349678713': 'previewCyan',
      '1349678681': 'previewYellow',
      '1349743685': 'posterEdges',
      '1349743689': 'pasteInto',
      '1349743726': 'position',
      '1349743695': 'pasteOutside',
      '1349743730': 'posterization',
      '1349743699': 'postScriptColor',
      '1349804904': 'patchwork',
      '1349806147': 'pathContents',
      '1349806155': 'pathKind',
      '1349806158': 'pathName',
      '1349806192': 'pathPoint',
      '1349806160': 'pathsPaletteOptions',
      '1349807684': 'patternDither',
      '1349808750': 'pattern',
      '1349808928': 'points',
      '1349809262': 'patternKey',
      '1350067564': 'pixel',
      '1350069328': 'pixelPaintFormat',
      '1350062897': 'pixelPaintSize1',
      '1350062898': 'pixelPaintSize2',
      '1350062899': 'pixelPaintSize3',
      '1350062900': 'pixelPaintSize4',
      '1350136429': 'pyramids',
      '1365472048': 'QCSCorner0',
      '1365472049': 'QCSCorner1',
      '1365472050': 'QCSCorner2',
      '1365472051': 'QCSCorner3',
      '1365472052': 'QCSSide0',
      '1365472053': 'QCSSide1',
      '1365472054': 'QCSSide2',
      '1365472055': 'QCSSide3',
      '1365472097': 'QCSAverage',
      '1365472105': 'QCSIndependent',
      '1363366772': 'quadCenterState',
      '1365537902': 'quadtone',
      '1366062201': 'quality',
      '1366647629': 'quickMask',
      '1903520116': 'quit',
      '1366651457': 'queryAlways',
      '1366651500': 'queryAsk',
      '1366651470': 'queryNever',
      '1366651475': 'queryState',
      '1382116967': 'range',
      '1382248038': 'recentFiles',
      '1382249521': 'rect16',
      '1382249582': 'rectangle',
      '1382249552': 'rectToPolar',
      '1382293536': 'red',
      '1382302316': 'redBlackPoint',
      '1382302573': 'redrawComplete',
      '1382303597': 'redGamma',
      '1382312992': 'radial',
      '1382313026': 'radialBlur',
      '1382314784': 'radius',
      '1382307688': 'redWhitePoint',
      '1382307872': 'redX',
      '1382308128': 'redY',
      '1382443364': 'renderFidelity',
      '1382444131': 'reflected',
      '1380401696': 'RGB',
      '1380401731': 'RGBColor',
      '1380401734': 'RGB48',
      '1380401741': 'RGBColorMode',
      '1380401747': 'RGBSetup',
      '1380401780': 'RGBSetupClass',
      '1382508624': 'roughPastels',
      '1382508660': 'right',
      '1382511437': 'registrationMarks',
      '1382835744': 'relief',
      '1382838856': 'rulerOriginH',
      '1382838869': 'rulerUnits',
      '1382838870': 'rulerOriginV',
      '1382839414': 'relative',
      '1382905410': 'removeBlackMatte',
      '1382905420': 'removeLayerMask',
      '1382905431': 'removeWhiteMatte',
      '1382966304': 'round',
      '1382966381': 'random',
      '1382966382': 'roundness',
      '1382966355': 'randomSeed',
      '1382968608': 'rename',
      '1383099459': 'replaceColor',
      '1383099493': 'ripple',
      '1383099469': 'rippleMagnitude',
      '1383099475': 'rippleSize',
      '1383101472': 'repeat',
      '1383101509': 'repeatEdgePixels',
      '1383220077': 'rulerCm',
      '1383221614': 'rulerInches',
      '1383223401': 'rulerPicas',
      '1383223410': 'rulerPercent',
      '1383223412': 'rulerPoints',
      '1383223416': 'rulerPixels',
      '1383294324': 'reset',
      '1383296116': 'resolution',
      '1383296368': 'resample',
      '1383297134': 'response',
      '1383297609': 'resourceID',
      '1383298162': 'rasterize',
      '1383298132': 'rasterizeTypeLayer',
      '1383342112': 'ratio',
      '1383359340': 'reticulation',
      '1383362120': 'retainHeader',
      '1383363408': 'rotoscopingPreferences',
      '1383363616': 'rotate',
      '1383363685': 'rotateEventEnum',
      '1383492673': 'revealAll',
      '1383492691': 'revealSelection',
      '1383494259': 'reverse',
      '1383494260': 'revert',
      '1383538720': 'rawFormat',
      '1381453658': 'resizeWindowsOnZoom',
      '1935767141': 'save',
      '1396854085': 'smartBlurModeEdgeOnly',
      '1396854094': 'smartBlurModeNormal',
      '1396854095': 'smartBlurModeOverlayEdge',
      '1398960236': 'subpathsList',
      '1398960204': 'subpathListKey',
      '1396855112': 'smartBlurQualityHigh',
      '1396855116': 'smartBlurQualityLow',
      '1396855117': 'smartBlurQualityMedium',
      '1398961222': 'subtractFrom',
      '1398961266': 'subtract',
      '1396925288': 'spotColorChannel',
      '1399024672': 'scale',
      '1399024712': 'scaleHorizontal',
      '1399024750': 'scaling',
      '1396927602': 'solidColor',
      '1399024726': 'scaleVertical',
      '1399025267': 'scans',
      '1399026243': 'screenCircle',
      '1399026244': 'scratchDisks',
      '1399026246': 'screenFile',
      '1399026252': 'screenLine',
      '1399026286': 'screen',
      '1399026288': 'fontScript',
      '1399026260': 'screenType',
      '1399026808': 'scitexCTFormat',
      '1396983930': 'strokeDirHorizontal',
      '1396992370': 'strokeDirection',
      '1396984900': 'strokeDirLeftDiag',
      '1396986436': 'strokeDirRightDiag',
      '1396987508': 'strokeDirVertical',
      '1935963971': 'shadowColor',
      '1935963981': 'shadowMode',
      '1935963983': 'shadowOpacity',
      '1399155813': 'selective',
      '1936028772': 'set',
      '1397052524': 'backgroundEraserTool',
      '1399210572': 'softMatte',
      '1399223372': 'softLight',
      '1399223406': 'softness',
      '1399350345': 'shadingIntensity',
      '1399350348': 'shadowLevels',
      '1399350350': 'shadingNoise',
      '1399350355': 'shadingShape',
      '1399350391': 'shadows',
      '1399350859': 'shiftKey',
      '1399343956': 'shiftKeyToolSwitch',
      '1399353376': 'shape',
      '1399353411': 'shapeCurveType',
      '1399353888': 'shear',
      '1399353925': 'sharpenEdges',
      '1399353932': 'shortLines',
      '1399353933': 'sharpenMore',
      '1399353934': 'shortNames',
      '1399353968': 'sharpen',
      '1399353936': 'shearPoints',
      '1399353939': 'shearSt',
      '1399346036': 'shortStrokes',
      '1399346284': 'sharpenTool',
      '1399346290': 'showTransparency',
      '1399355168': 'show',
      '1399355205': 'showEnglishFontNames',
      '1399355220': 'showToolTips',
      '1399547255': 'skew',
      '1399612225': 'selectedAreas',
      '1399612227': 'selectiveColor',
      '1936483188': 'select',
      '1399612276': 'selectionEnum',
      '1399614836': 'slopeLimitMatte',
      '1399616122': 'solarize',
      '1399616321': 'stylesAppend',
      '1399616356': 'stylesLoad',
      '1399616358': 'stylesDelete',
      '1399616334': 'stylesNew',
      '1399616338': 'stylesReset',
      '1399616374': 'stylesSave',
      '1399669325': 'smartBlurMode',
      '1399669329': 'smartBlurQuality',
      '1399678035': 'smudgeStick',
      '1399679333': 'sumie',
      '1399680032': 'small',
      '1399680114': 'similar',
      '1399680879': 'smooth',
      '1399681075': 'sample3x3',
      '1399681077': 'sample5x5',
      '1397575747': 'SMPTEC',
      '1399681104': 'samplePoint',
      '1397575764': 'adobeRGB1998',
      '1399681602': 'smartBlur',
      '1399682152': 'smoothness',
      '1399673964': 'smudgeTool',
      '1399744355': 'singleColumn',
      '1399744370': 'singleRow',
      '1399746633': 'snapshotInitial',
      '1399746675': 'snapshotEnum',
      '1399746643': 'snapshotClass',
      '1399801449': 'solidFill',
      '1936732209': 'shapeCurveLinear',
      '1936732210': 'shapeCurveGaussian',
      '1936732211': 'shapeCurveSingle',
      '1936732212': 'shapeCurveDouble',
      '1936732213': 'shapeCurveTriple',
      '1936732214': 'shapeCurveCustom',
      '1399874377': 'specialInstructions',
      '1399874414': 'spacing',
      '1399874420': 'spectrum',
      '1399875661': 'spherizeMode',
      '1399875698': 'spherize',
      '1399876675': 'splitChannels',
      '1399877152': 'spin',
      '1399877223': 'sponge',
      '1399877492': 'spot',
      '1399878226': 'sprayRadius',
      '1399878227': 'separationSetup',
      '1399878260': 'separations',
      '1399878228': 'separationTables',
      '1399878688': 'spatter',
      '1399943712': 'square',
      '1399943763': 'squareSize',
      '1400005426': 'source2',
      '1400005442': 'srcBlackMin',
      '1400005443': 'centerGlow',
      '1400005477': 'source',
      '1400005445': 'edgeGlow',
      '1400005484': 'srcBlackMax',
      '1400005485': 'srcWhiteMax',
      '1400005453': 'sourceMode',
      '1400005463': 'srcWhiteMin',
      '1397901122': 'sRGB',
      '1936877416': 'strength',
      '1936877394': 'strengthRatio',
      '1400007763': 'serialString',
      '1400001644': 'saturationTool',
      '1400075337': 'systemInfo',
      '1400075344': 'systemPalette',
      '1400136736': 'standard',
      '1400136769': 'stdA',
      '1400136770': 'stdB',
      '1400136771': 'stdC',
      '1400136773': 'stdE',
      '1400128628': 'strokeDetail',
      '1400137586': 'stagger',
      '1400138819': 'stylusIsColor',
      '1400138831': 'stylusIsOpacity',
      '1400138832': 'stylusIsPressure',
      '1400138835': 'stylusIsSize',
      '1400139120': 'stamp',
      '1400139335': 'stainedGlass',
      '1400139632': 'stop',
      '1400140320': 'saturate',
      '1400140353': 'startArrowhead',
      '1400140356': 'strokeDirectionType',
      '1400140358': 'stretchToFit',
      '1400140391': 'strengthPlugin',
      '1400140395': 'stroke',
      '1400140364': 'strokeLength',
      '1400140368': 'strokePressure',
      '1400140371': 'strokeSize',
      '1400140404': 'saturation',
      '1400140375': 'strokeWidth',
      '1400140901': 'state',
      '1400142147': 'styleClass',
      '1400142188': 'style',
      '1400142195': 'styles',
      '1400258926': 'saveAndClose',
      '1400259437': 'saveComposite',
      '1400268132': 'saved',
      '1400268407': 'saveForWeb',
      '1400270406': 'savingFilesPreferences',
      '1400270439': 'saving',
      '1400262772': 'savePaths',
      '1400262777': 'savePyramids',
      '1400337473': 'swatchesAppend',
      '1400337520': 'swatchesReplace',
      '1400337490': 'swatchesReset',
      '1400337491': 'swatchesSave',
      '1400468304': 'systemPicker',
      '1400512544': 'size',
      '1411391520': 'to',
      '1415736352': 'tables',
      '1413639200': 'toBuiltin',
      '1415861280': '3DTransform',
      '1952740449': 'rawData',
      '1413830740': 'char',
      '1416053328': 'toggleBlackPreview',
      '1416053581': 'toggleCMYPreview',
      '1416053584': 'toggleCyanPreview',
      '1416054642': 'toggleGrid',
      '1416064065': 'toggleActionsPalette',
      '1416064066': 'toggleBrushesPalette',
      '1416064099': 'toggleColorPalette',
      '1416064067': 'toggleCMYKPreview',
      '1416064100': 'toggleGuides',
      '1416064069': 'toggleEdges',
      '1416064071': 'toggleGamutWarning',
      '1416064104': 'toggleChannelsPalette',
      '1416064072': 'toggleHistoryPalette',
      '1416064073': 'toggleInfoPalette',
      '1416064076': 'toggleLockGuides',
      '1416064077': 'toggleLayerMask',
      '1416064078': 'toggleNavigatorPalette',
      '1416064079': 'toggleOptionsPalette',
      '1416064080': 'togglePaths',
      '1416064082': 'toggleRulers',
      '1416064115': 'toggleStatusBar',
      '1416064083': 'toggleSnapToGuides',
      '1416064116': 'togglePathsPalette',
      '1416064084': 'toggleToolsPalette',
      '1416064119': 'toggleSwatchesPalette',
      '1416064121': 'toggleLayersPalette',
      '1416056144': 'toggleMagentaPreview',
      '1416057708': 'toggleStylesPalette',
      '1416057710': 'toggleSnapToGrid',
      '1416059216': 'toggleYellowPreview',
      '1416129890': 'thumbnail',
      '1416131176': 'thresholdEnum',
      '1416131187': 'thresholdClassEvent',
      '1416131432': 'threshold',
      '1414088262': 'TIFF',
      '1416195173': 'tile',
      '1416318322': 'takeMergedSnapshot',
      '1416319854': 'takeSnapshot',
      '1416372256': 'tilePlugin',
      '1416384109': 'tileNumber',
      '1416384358': 'tileOffset',
      '1416393326': 'tolerance',
      '1416393504': 'tiles',
      '1416385402': 'tileSize',
      '1414358048': 'toMode',
      '1416580203': 'toLinked',
      '1416589164': 'tool',
      '1416589344': 'top',
      '1416782192': 'trap',
      '1416782659': 'traceContour',
      '1416782699': 'tracking',
      '1416783472': 'transferSpecClass',
      '1416783686': 'targaFormat',
      '1416783728': 'targetPath',
      '1416783696': 'targetPathIndex',
      '1416783732': 'targetEnum',
      '1416777072': 'toggleRGBMacPreview',
      '1416785475': 'transparencyGridColors',
      '1416785477': 'tornEdges',
      '1416785510': 'transform',
      '1416785478': 'transferFunction',
      '1416785479': 'transparencyGamutPreferences',
      '1416785481': 'transparentIndex',
      '1416785516': 'transparencyGridColorsType',
      '1416785488': 'transparencyPrefs',
      '1416785523': 'transparency',
      '1416785491': 'transferSpec',
      '1416785524': 'trinitron',
      '1416785495': 'transparentWhites',
      '1416786800': 'transparencyEnum',
      '1416787054': 'tritone',
      '1416779120': 'toggleRGBUncompensatedPreview',
      '1416779632': 'toggleRGBWindowsPreview',
      '1416916000': 'title',
      '1416916044': 'totalLimit',
      '1417114220': 'twirl',
      '1417114484': 'twist',
      '1417167468': 'texTypeBlocks',
      '1417167474': 'texTypeBrick',
      '1417167477': 'texTypeBurlap',
      '1417167713': 'texTypeCanvas',
      '1417168498': 'texTypeFrosted',
      '1417170034': 'textLayer',
      '1417170041': 'obsoleteTextLayer',
      '1417171828': 'texTypeSandstone',
      '1417180192': 'textKey',
      '1417180227': 'textClickPoint',
      '1417180228': 'textData',
      '1417180230': 'textureFile',
      '1417172044': 'texTypeTinyLens',
      '1417180274': 'texture',
      '1417180243': 'textStyle',
      '1417180276': 'textStyleRange',
      '1417180244': 'textureType',
      '1417180282': 'texturizer',
      '1954115685': 'class',
      '1417244773': 'type',
      '1430418541': 'uIBitmap',
      '1430462496': 'UCA',
      '1430474073': 'uICMYK',
      '1430549614': 'uIDuotone',
      '1969712231': 'useGlobalAngle',
      '1430745721': 'uIGrayscale',
      '1430875748': 'uIIndexed',
      '1431069026': 'uILab',
      '1431137396': 'uIMultichannel',
      '1433297952': 'undoEnum',
      '1433297985': 'undefinedArea',
      '1433298028': 'underline',
      '1970168943': 'undoEvent',
      '1433298034': 'underpainting',
      '1433298541': 'uniform',
      '1433298546': 'uniformDistribution',
      '1433298802': 'ungroup',
      '1433300075': 'unlink',
      '1433301827': 'unspecifiedColor',
      '1433301837': 'unsharpMask',
      '1433302086': 'floatUnit',
      '1433302124': 'untitled',
      '1433302096': 'unitsPrefs',
      '1433302098': 'unitsRulersPreferences',
      '1433432153': 'upperY',
      '1433432608': 'upper',
      '1431455554': 'uIRGB',
      '1433560942': 'urgency',
      '1431456800': 'URL',
      '1433617251': 'useCacheForHistograms',
      '1433617266': 'useCurves',
      '1433617510': 'useDefault',
      '1433618755': 'useICCProfile',
      '1433619827': 'useMask',
      '1433628263': 'using',
      '1433629261': 'userMaskEnabled',
      '1433629299': 'userMaskLinked',
      '1433629267': 'userStop',
      '1449358384': 'vector0',
      '1449358385': 'vector1',
      '1449358403': 'vectorColor',
      '1449421936': 'videoAlpha',
      '1449926688': 'value',
      '1449938035': 'valueList',
      '1449948192': 'violet',
      '1447907442': 'vMPreferences',
      '1450341190': 'versionFix',
      '1450341197': 'versionMajor',
      '1450341230': 'version',
      '1450341198': 'versionMinor',
      '1450341475': 'vertical',
      '1450341452': 'verticalLocation',
      '1450341486': 'variations',
      '1450341455': 'verticalOnly',
      '1450341459': 'verticalScale',
      '1450402412': 'visible',
      '1466001780': 'wait',
      '2002875506': 'watermark',
      '1466005093': 'wave',
      '1466201192': 'width',
      '1466262048': 'web',
      '1466458484': 'what',
      '1466452073': 'whiteIsHigh',
      '1466454132': 'wholePath',
      '1466463264': 'white',
      '1466463299': 'whiteClip',
      '1466463305': 'whiteIntensity',
      '1466463308': 'whiteLevel',
      '1466463312': 'whitePoint',
      '1466463347': 'whites',
      '1466524773': 'widePhosphors',
      '1466527264': 'windows',
      '1466528872': 'with',
      '1464618350': 'wavelengthMin',
      '1464618360': 'wavelengthMax',
      '1466852384': 'wind',
      '1466852429': 'windMethod',
      '1466852435': 'windowsSystem',
      '1466848360': 'winThumbnail',
      '1465009986': 'wideGamutRGB',
      '1467116368': 'workPathIndex',
      '1467117600': 'wrap',
      '1467117633': 'wrapAround',
      '1467109492': 'workPath',
      '1467245395': 'watchSuspension',
      '1467245671': 'wetEdges',
      '1467249251': 'watercolor',
      '1467249232': 'waterPaper',
      '1467372398': 'waveSine',
      '1467372401': 'waveSquare',
      '1467380848': 'waveType',
      '1467372658': 'waveTriangle',
      '1478500384': 'x',
      '1482910837': 'exclusion',
      '1482250563': 'xYYColor',
      '1495277600': 'y',
      '1500277879': 'yellow',
      '1500280608': 'yellowColor',
      '1500280691': 'yellows',
      '1500717088': 'yes',
      '1500728864': 'yesNo',
      '1516722791': 'zigZag',
      '1517101088': 'zoom',
      '1517111662': 'zoomIn',
      '1517113204': 'zoomOut',
      '1517307246': 'zip',
      '1515869305': 'zigZagType'
    };

    return PSDConstants;

  })();

  Parser = (function() {

    function Parser() {}

    Parser.zeroFill = function(number, width) {
      if (width == null) {
        width = 2;
      }
      width -= number.toString().length - /\./.test(number);
      if (width > 0) {
        return new Array(width + 1).join('0') + number;
      }
      return number + "";
    };

    Parser.parseColor = function(color_object, opacity) {
      var bb, bhex, color_string, gg, ghex, rhex, rr;
      if (opacity == null) {
        opacity = 1.00;
      }
      if (color_object["class"].id === 1380401731) {
        if (parseInt(opacity * 100) === 100 || parseInt(opacity * 100) === 0) {
          rr = this.zeroFill(parseInt(color_object.red).toString(16));
          gg = this.zeroFill(parseInt(color_object.grain).toString(16));
          bb = this.zeroFill(parseInt(color_object.blue).toString(16));
          color_string = "#" + rr + gg + bb;
        } else {
          rhex = parseInt(color_object.red);
          ghex = parseInt(color_object.grain);
          bhex = parseInt(color_object.blue);
          color_string = "rgba(" + rhex + ", " + ghex + ", " + bhex + ", " + opacity + ")";
        }
        return color_string;
      }
    };

    Parser.parseGradient = function(gradient_object) {
      var color, color_object, color_stops, gradient, gradient_type, location_percentage, opacity_stops, overall_length, transparency_object, _i, _j, _len, _len1, _ref, _ref1;
      gradient_type = PSDConstants.CONSTANTS[gradient_object.type];
      overall_length = gradient_object.gradient.interfaceIconFrameDimmed;
      opacity_stops = {};
      _ref = gradient_object.gradient.transparency;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        transparency_object = _ref[_i];
        location_percentage = Math.round((100 * transparency_object.location) / overall_length);
        opacity_stops[location_percentage] = parseFloat(transparency_object.opacity.value / 100).toFixed(2);
      }
      color_stops = [];
      _ref1 = gradient_object.gradient.colors;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        color_object = _ref1[_j];
        location_percentage = Math.round((100 * color_object.location) / overall_length);
        if (opacity_stops[location_percentage] != null) {
          color = this.parseColor(color_object.color, opacity_stops[location_percentage]);
        } else {
          color = this.parseColor(color_object.color);
        }
        color_stops.push("" + color + " " + location_percentage + "%");
      }
      switch (gradient_type) {
        case "linear":
          gradient = {
            type: gradient_type,
            angle: gradient_object.angle.value,
            color_stops: color_stops
          };
          break;
        case "radial":
          gradient = {
            type: gradient_type,
            scale: gradient_object.scale.value,
            color_stops: color_stops
          };
          break;
        default:
          console.log("Unhandled gradient type: " + gradient_type);
      }
      return gradient;
    };

    Parser.parsePattern = function(pattern_object) {
      var pattern;
      pattern = {
        uid: pattern_object.pattern.ID,
        name: pattern_object.pattern.name
      };
      return pattern;
    };

    Parser.parseBorder = function(border_object) {
      var border, opacity;
      opacity = parseFloat(border_object.opacity.value / 100).toFixed(2);
      return border = {
        color: this.parseColor(border_object.color, opacity),
        width: "" + border_object.size.value + "px",
        type: PSDConstants.CONSTANTS[border_object.style]
      };
    };

    Parser.parseShadow = function(shadow_object, shadow_type) {
      var angle, distance, horizontal_offset, opacity, shadow, vertical_offset;
      if (shadow_type == null) {
        shadow_type = "box";
      }
      opacity = parseFloat(shadow_object.opacity.value / 100).toFixed(2);
      distance = shadow_object.distance.value;
      angle = (Math.PI * shadow_object.localLightingAngle.value) / 180;
      horizontal_offset = Math.round(Math.abs(distance * Math.sin(angle)));
      vertical_offset = Math.round(Math.abs(distance * Math.cos(angle)));
      shadow = {
        color: this.parseColor(shadow_object.color, opacity),
        horizontal_offset: "" + horizontal_offset + "px",
        vertical_offset: "" + vertical_offset + "px",
        blur: "" + shadow_object.blur.value + "px",
        spread: "" + shadow_object.noise.value + "px",
        type: "" + shadow_type
      };
      return shadow;
    };

    Parser.parseEffects = function(effects_object) {
      var layer_effect, layer_effects, opacity, parsed_effects, _i, _len;
      layer_effects = Object.keys(effects_object);
      parsed_effects = {};
      for (_i = 0, _len = layer_effects.length; _i < _len; _i++) {
        layer_effect = layer_effects[_i];
        if (effects_object[layer_effect].enabled === false) {
          continue;
        }
        switch (layer_effect) {
          case "dropShadow":
            parsed_effects.box_shadow = this.parseShadow(effects_object['dropShadow']);
            break;
          case "innerShadow":
            parsed_effects.inner_shadow = this.parseShadow(effects_object['dropShadow'], "inset");
            break;
          case "frameFX":
            parsed_effects.border = this.parseBorder(effects_object['frameFX']);
            break;
          case "solidFill":
            opacity = parseFloat(effects_object['solidFill'].opacity.value / 100).toFixed(2);
            parsed_effects.solidFill = this.parseColor(effects_object['solidFill'].color, opacity);
            break;
          case "gradientFill":
            parsed_effects.gradientFill = this.parseGradient(effects_object['gradientFill']);
            break;
          case "patternFill":
            parsed_effects.patternFill = this.parsePattern(effects_object['patternFill']);
        }
      }
      return parsed_effects;
    };

    return Parser;

  })();

  if (typeof exports !== "undefined" && exports !== null) {
    Root = exports;
    fs = require('fs');
  } else {
    Root = window;
  }

  Root.PSD = PSD = (function() {

    PSD.VERSION = "0.4.5";

    PSD.DEBUG = false;

    PSD.fromFile = function(file, cb) {
      var data, reader;
      if (cb == null) {
        cb = function() {};
      }
      if (typeof exports !== "undefined" && exports !== null) {
        data = fs.readFileSync(file);
        return new PSD(data);
      } else {
        reader = new FileReader();
        reader.onload = function(f) {
          var bytes, psd;
          bytes = new Uint8Array(f.target.result);
          psd = new PSD(bytes);
          return cb(psd);
        };
        return reader.readAsArrayBuffer(file);
      }
    };

    PSD.fromURL = function(url, cb) {
      var xhr;
      if (cb == null) {
        cb = function() {};
      }
      xhr = new XMLHttpRequest;
      xhr.open("GET", url, true);
      xhr.responseType = "arraybuffer";
      xhr.onload = function() {
        var data, psd;
        data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
        psd = new PSD(data);
        return cb(psd);
      };
      return xhr.send(null);
    };

    PSD.prototype.options = {
      layerImages: false,
      onlyVisibleLayers: false
    };

    function PSD(data) {
      this.file = new PSDFile(data);
      this.header = null;
      this.resources = null;
      this.layerMask = null;
      this.layers = null;
      this.images = null;
      this.image = null;
    }

    PSD.prototype.setOptions = function(options) {
      var key, val, _results;
      _results = [];
      for (key in options) {
        if (!__hasProp.call(options, key)) continue;
        val = options[key];
        _results.push(this.options[key] = val);
      }
      return _results;
    };

    PSD.prototype.parse = function() {
      Log.debug("Beginning parsing");
      this.startTime = (new Date()).getTime();
      this.parseHeader();
      this.parseImageResources();
      this.parseLayersMasks();
      this.parseImageData();
      this.endTime = (new Date()).getTime();
      return Log.debug("Parsing finished in " + (this.endTime - this.startTime) + "ms");
    };

    PSD.prototype.parseHeader = function() {
      Log.debug("\n### Header ###");
      this.header = new PSDHeader(this.file);
      this.header.parse();
      return Log.debug(this.header);
    };

    PSD.prototype.parseImageResources = function(skip) {
      var length, n, pos, resource, start;
      if (skip == null) {
        skip = false;
      }
      Log.debug("\n### Resources ###");
      this.resources = [];
      n = this.file.readInt();
      length = n;
      if (skip) {
        Log.debug("Skipped!");
        return this.file.seek(n);
      }
      start = this.file.tell();
      while (n > 0) {
        pos = this.file.tell();
        resource = new PSDResource(this.file);
        resource.parse();
        n -= this.file.tell() - pos;
        this.resources.push(resource);
        Log.debug("Resource: ", resource);
      }
      if (n !== 0) {
        Log.debug("Image resources overran expected size by " + (-n) + " bytes");
        return this.file.seek(start + length);
      }
    };

    PSD.prototype.parseLayersMasks = function(skip) {
      if (skip == null) {
        skip = false;
      }
      if (!this.header) {
        this.parseHeader();
      }
      if (!this.resources) {
        this.parseImageResources(true);
      }
      Log.debug("\n### Layers & Masks ###");
      this.layerMask = new PSDLayerMask(this.file, this.header, this.options);
      this.layers = this.layerMask.layers;
      if (skip) {
        Log.debug("Skipped!");
        return this.layerMask.skip();
      } else {
        return this.layerMask.parse();
      }
    };

    PSD.prototype.parseImageData = function() {
      if (!this.header) {
        this.parseHeader();
      }
      if (!this.resources) {
        this.parseImageResources(true);
      }
      if (!this.layerMask) {
        this.parseLayersMasks(true);
      }
      this.image = new PSDImage(this.file, this.header);
      return this.image.parse();
    };

    PSD.prototype.getLayerStructure = function() {
      var layer, parseStack, result, temp, _i, _len, _ref;
      if (!this.layerMask) {
        this.parseLayersMasks();
      }
      result = {
        layers: []
      };
      parseStack = [];
      _ref = this.layers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        layer = _ref[_i];
        if (layer.isFolder) {
          parseStack.push(result);
          result = {
            name: layer.name,
            layers: []
          };
        } else if (layer.isHidden) {
          temp = result;
          result = parseStack.pop();
          result.layers.push(temp);
        } else {
          result.layers.push(layer);
        }
      }
      return result;
    };

    PSD.prototype.hasClippingLayers = function() {
      var clipping, layer, _i, _len, _ref;
      if (!this.layers) {
        return null;
      }
      clipping = 0;
      _ref = this.layers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        layer = _ref[_i];
        if (layer.blendMode.clipping === 1) {
          clipping++;
        }
      }
      return clipping > 0;
    };

    PSD.prototype.toFile = function(filename, cb) {
      if (cb == null) {
        cb = function() {};
      }
      if (!this.image) {
        this.parseImageData();
      }
      return this.image.toFile(filename, cb);
    };

    PSD.prototype.toFileSync = function(filename) {
      if (!this.image) {
        this.parseImageData();
      }
      return this.image.toFileSync(filename);
    };

    PSD.prototype.toCanvas = function(canvas, width, height) {
      if (width == null) {
        width = null;
      }
      if (height == null) {
        height = null;
      }
      if (!this.image) {
        this.parseImageData();
      }
      return this.image.toCanvas(canvas, width, height);
    };

    PSD.prototype.toImage = function() {
      if (!this.image) {
        this.parseImageData();
      }
      return this.image.toImage();
    };

    PSD.prototype.toJSON = function() {
      var data, section, sections, _i, _len;
      if (!this.layerMask) {
        this.parseLayersMasks();
      }
      sections = ['layerMask'];
      data = {};
      for (_i = 0, _len = sections.length; _i < _len; _i++) {
        section = sections[_i];
        data[section] = this[section].toJSON();
      }
      return data;
    };

    return PSD;

  })();

  PSD.PSDColor = PSDColor = (function() {

    function PSDColor() {}

    PSDColor.hexToRGB = function(hex) {
      var b, g, r;
      if (hex.charAt(0) === "#") {
        hex = hex.substr(1);
      }
      r = parseInt(hex.substr(0, 2), 16);
      g = parseInt(hex.substr(2, 2), 16);
      b = parseInt(hex.substr(4, 2), 16);
      return {
        r: r,
        g: g,
        b: b
      };
    };

    PSDColor.rgbToHex = function(c) {
      var m;
      if (arguments.length === 1) {
        m = /rgba?\((\d+), (\d+), (\d+)/.exec(c);
      } else {
        m = Array.prototype.slice.call(arguments);
        m.unshift(0);
      }
      if (m) {
        return '#' + (m[1] << 16 | m[2] << 8 | m[3]).toString(16);
      } else {
        return c;
      }
    };

    PSDColor.rgbToHSL = function(r, g, b) {
      var d, h, l, max, min, s;
      r /= 255;
      g /= 255;
      b /= 255;
      max = Math.max(r, g, b);
      min = Math.min(r, g, b);
      l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        h = (function() {
          switch (max) {
            case r:
              return (g - b) / d + (g < b ? 6 : 0);
            case g:
              return (b - r) / d + 2;
            case b:
              return (r - g) / d + 4;
          }
        })();
        h /= 6;
      }
      return {
        h: Util.round(h, 3),
        s: Util.round(s, 3),
        l: Util.round(l, 3)
      };
    };

    PSDColor.hslToRGB = function(h, s, l) {
      var b, g, p, q, r;
      if (s === 0) {
        r = g = b = l;
      } else {
        q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        p = 2 * l - q;
        r = this.hueToRGB(p, q, h + 1 / 3);
        g = this.hueToRGB(p, q, h);
        b = this.hueToRGB(p, q, h - 1 / 3);
      }
      r *= 255;
      g *= 255;
      b *= 255;
      return {
        r: Math.round(r),
        g: Math.round(g),
        b: Math.round(b)
      };
    };

    PSDColor.hueToRGB = function(p, q, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
      }
      if (t < 1 / 2) {
        return q;
      }
      if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
      }
      return p;
    };

    PSDColor.rgbToHSV = function(r, g, b) {
      var d, h, max, min, s, v;
      r /= 255;
      g /= 255;
      b /= 255;
      max = Math.max(r, g, b);
      min = Math.min(r, g, b);
      v = max;
      d = max - min;
      s = max === 0 ? 0 : d / max;
      if (max === min) {
        h = 0;
      } else {
        h = (function() {
          switch (max) {
            case r:
              return (g - b) / d + (g < b ? 6 : 0);
            case g:
              return (b - r) / d + 2;
            case b:
              return (r - g) / d + 4;
          }
        })();
        h /= 6;
      }
      return {
        h: h,
        s: s,
        v: v
      };
    };

    PSDColor.hsvToRGB = function(h, s, v) {
      var b, f, g, i, p, q, r, t;
      i = Math.floor(h * 6);
      f = h * 6 - i;
      p = v * (1 - s);
      q = v * (1 - f * s);
      t = v * (1 - (1 - f) * s);
      switch (i % 6) {
        case 0:
          r = v;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = v;
          b = p;
          break;
        case 2:
          r = p;
          g = v;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = v;
          break;
        case 4:
          r = t;
          g = p;
          b = v;
          break;
        case 5:
          r = v;
          g = p;
          b = q;
      }
      return Util.clamp({
        r: r * 255,
        g: g * 255,
        b: b * 255
      }, 0, 255);
    };

    PSDColor.rgbToXYZ = function(r, g, b) {
      var x, y, z;
      r /= 255;
      g /= 255;
      b /= 255;
      if (r > 0.04045) {
        r = Math.pow((r + 0.055) / 1.055, 2.4);
      } else {
        r /= 12.92;
      }
      if (g > 0.04045) {
        g = Math.pow((g + 0.055) / 1.055, 2.4);
      } else {
        g /= 12.92;
      }
      if (b > 0.04045) {
        b = Math.pow((b + 0.055) / 1.055, 2.4);
      } else {
        b /= 12.92;
      }
      x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return {
        x: x * 100,
        y: y * 100,
        z: z * 100
      };
    };

    PSDColor.xyzToRGB = function(x, y, z) {
      var b, g, r;
      x /= 100;
      y /= 100;
      z /= 100;
      r = (3.2406 * x) + (-1.5372 * y) + (-0.4986 * z);
      g = (-0.9689 * x) + (1.8758 * y) + (0.0415 * z);
      b = (0.0557 * x) + (-0.2040 * y) + (1.0570 * z);
      if (r > 0.0031308) {
        r = (1.055 * Math.pow(r, 0.4166666667)) - 0.055;
      } else {
        r *= 12.92;
      }
      if (g > 0.0031308) {
        g = (1.055 * Math.pow(g, 0.4166666667)) - 0.055;
      } else {
        g *= 12.92;
      }
      if (b > 0.0031308) {
        b = (1.055 * Math.pow(b, 0.4166666667)) - 0.055;
      } else {
        b *= 12.92;
      }
      return Util.clamp({
        r: r * 255,
        g: g * 255,
        b: b * 255
      }, 0, 255);
    };

    PSDColor.xyzToLab = function(x, y, z) {
      var a, b, l, whiteX, whiteY, whiteZ;
      whiteX = 95.047;
      whiteY = 100.0;
      whiteZ = 108.883;
      x /= whiteX;
      y /= whiteY;
      z /= whiteZ;
      if (x > 0.008856451679) {
        x = Math.pow(x, 0.3333333333);
      } else {
        x = (7.787037037 * x) + 0.1379310345;
      }
      if (y > 0.008856451679) {
        y = Math.pow(y, 0.3333333333);
      } else {
        y = (7.787037037 * y) + 0.1379310345;
      }
      if (z > 0.008856451679) {
        z = Math.pow(z, 0.3333333333);
      } else {
        z = (7.787037037 * z) + 0.1379310345;
      }
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return {
        l: l,
        a: a,
        b: b
      };
    };

    PSDColor.labToXYZ = function(l, a, b) {
      var x, y, z;
      y = (l + 16) / 116;
      x = y + (a / 500);
      z = y - (b / 200);
      if (Math.pow(x, 3) > 0.008856) {
        x = Math.pow(x, 3);
      } else {
        x = (x - 16 / 116) / 7.787;
      }
      if (Math.pow(y, 3) > 0.008856) {
        y = Math.pow(y, 3);
      } else {
        y = (y - 16 / 116) / 7.787;
      }
      if (Math.pow(z, 3) > 0.008856) {
        z = Math.pow(z, 3);
      } else {
        z = (z - 16 / 116) / 7.787;
      }
      return {
        x: x * 95.047,
        y: y * 100.0,
        z: z * 108.883
      };
    };

    PSDColor.labToRGB = function(l, a, b) {
      var xyz;
      xyz = this.labToXYZ(l, a, b);
      return Util.clamp(this.xyzToRGB(xyz.x, xyz.y, xyz.z), 0, 255);
    };

    PSDColor.cmykToRGB = function(c, m, y, k) {
      var b, g, r;
      r = (65535 - (c * (255 - k) + (k << 8))) >> 8;
      g = (65535 - (m * (255 - k) + (k << 8))) >> 8;
      b = (65535 - (y * (255 - k) + (k << 8))) >> 8;
      return Util.clamp({
        r: r,
        g: g,
        b: b
      }, 0, 255);
    };

    PSDColor.rgbToColor = function(r, g, b) {
      return this.argbToColor(255, r, g, b);
    };

    PSDColor.argbToColor = function(a, r, g, b) {
      return (alpha << 24) | (r << 16) | (g << 8) | b;
    };

    PSDColor.hsbToColor = function(h, s, b) {
      return this.ahsbToColor(255, h, s, b);
    };

    PSDColor.ahsbToColor = function(alpha, hue, saturation, brightness) {
      var b, g, m1, m2, r;
      if (saturation === 0) {
        b = g = r = 255 * brightness;
      } else {
        if (brightness <= 0.5) {
          m2 = brightness * (1 + saturation);
        } else {
          m2 = brightness + saturation - brightness * saturation;
        }
        m1 = 2 * brightness - m2;
        r = this.hueToColor(hue + 120, m1, m2);
        g = this.hueToColor(hue, m1, m2);
        b = this.hueToColor(hue - 120, m1, m2);
      }
      return this.argbToColor(alpha, r, g, b);
    };

    PSDColor.hueToColor = function(hue, m1, m2) {
      var v;
      hue %= 360;
      if (hue < 60) {
        v = m1 + (m2 - m1) * hue / 60;
      } else if (hue < 180) {
        v = m2;
      } else if (hue < 240) {
        v = m1 + (m2 - m1) * (240 - hue) / 60;
      } else {
        v = m1;
      }
      return v * 255;
    };

    PSDColor.cmykToColor = function(cyan, magenta, yellow, black) {
      var b, g, r;
      r = 1 - (cyan * (1 - black) + black) * 255;
      g = 1 - (magenta * (1 - black) + black) * 255;
      b = 1 - (yellow * (1 - black) + black) * 255;
      r = Util.clamp(r, 0, 255);
      g = Util.clamp(g, 0, 255);
      b = Util.clamp(b, 0, 255);
      return this.rgbToColor(r, g, b);
    };

    PSDColor.labToColor = function(l, a, b) {
      return this.alabToColor(255, l, a, b);
    };

    PSDColor.alabToColor = function(alpha, lightness, a, b) {
      var xyz;
      xyz = this.labToXYZ(lightness, a, b);
      return this.axyzToColor(alpha, xyz.x, xyz.y, xyz.z);
    };

    PSDColor.axyzToColor = function(alpha, x, y, z) {
      var rgb;
      rgb = this.xyzToRGB(x, y, z);
      return this.argbToColor(alpha, rgb.r, rgb.g, rgb.b);
    };

    PSDColor.colorSpaceToARGB = function(colorSpace, colorComponent) {
      var dstColor;
      switch (colorSpace) {
        case 0:
          dstColor = this.rgbToColor(colorComponent[0], colorComponent[1], colorComponent[2]);
          break;
        case 1:
          dstColor = this.hsbToColor(colorComponent[0], colorComponent[1] / 100.0, colorComponent[2] / 100.0);
          break;
        case 2:
          dstColor = this.cmykToColor(colorComponent[0] / 100.0, colorComponent[1] / 100.0, colorComponent[2] / 100.0, colorComponent[3] / 100.0);
          break;
        case 7:
          dstColor = this.labToColor(colorComponent[0], colorComponent[1], colorComponent[2]);
          break;
        default:
          dstColor = 0x00FFFFFF;
      }
      return dstColor;
    };

    return PSDColor;

  })();

  PSDDescriptor = (function() {

    function PSDDescriptor(file) {
      this.file = file;
    }

    PSDDescriptor.prototype.parse = function() {
      var constants, data, i, item, item_key, numItems, _i;
      Log.debug("Parsing descriptor...");
      data = {};
      data["class"] = this.parseClass();
      numItems = this.file.readInt();
      Log.debug("Descriptor contains " + numItems + " items");
      constants = PSDConstants.CONSTANTS;
      for (i = _i = 0; 0 <= numItems ? _i < numItems : _i > numItems; i = 0 <= numItems ? ++_i : --_i) {
        item = this.parseKeyItem();
        item_key = constants[item.id];
        if (item_key != null) {
          data[item_key] = item.value;
        } else {
          data[item.id] = item.value;
        }
      }
      return data;
    };

    PSDDescriptor.prototype.parseID = function() {
      var len;
      len = this.file.readInt();
      if (len === 0) {
        return this.file.readInt();
      } else {
        return this.file.readString(len);
      }
    };

    PSDDescriptor.prototype.parseClass = function() {
      return {
        name: this.file.readUnicodeString(),
        id: this.parseID()
      };
    };

    PSDDescriptor.prototype.parseKeyItem = function() {
      var id, value;
      id = this.parseID();
      value = this.parseItem(id);
      return {
        id: id,
        value: value
      };
    };

    PSDDescriptor.prototype.parseItem = function(id, type) {
      var value;
      if (type == null) {
        type = null;
      }
      if (!type) {
        type = this.file.readString(4);
      }
      Log.debug("Found descriptor type: " + type);
      value = (function() {
        switch (type) {
          case 'bool':
            return this.parseBoolean();
          case 'type':
          case 'GlbC':
            return this.parseClass();
          case 'Objc':
          case 'GlbO':
            return this.parse();
          case 'doub':
            return this.parseDouble();
          case 'enum':
            return this.parseEnum();
          case 'alis':
            return this.parseAlias();
          case 'Pth ':
            return this.parseFilePath();
          case 'long':
            return this.parseInteger();
          case 'comp':
            return this.parseLargeInteger();
          case 'VlLs':
            return this.parseList();
          case 'ObAr':
            return this.parseObjectArray();
          case 'tdta':
            return this.parseRawData();
          case 'obj ':
            return this.parseReference();
          case 'TEXT':
            return this.file.readUnicodeString();
          case 'UntF':
            return this.parseUnitDouble();
        }
      }).call(this);
      return value;
    };

    PSDDescriptor.prototype.parseBoolean = function() {
      return this.file.readBoolean();
    };

    PSDDescriptor.prototype.parseDouble = function() {
      return this.file.readDouble();
    };

    PSDDescriptor.prototype.parseInteger = function() {
      return this.file.readInt();
    };

    PSDDescriptor.prototype.parseLargeInteger = function() {
      return this.file.readLongLong();
    };

    PSDDescriptor.prototype.parseIdentifier = function() {
      return this.file.readInt();
    };

    PSDDescriptor.prototype.parseIndex = function() {
      return this.file.readInt();
    };

    PSDDescriptor.prototype.parseOffset = function() {
      return this.file.readInt();
    };

    PSDDescriptor.prototype.parseProperty = function() {
      return this.parseID();
    };

    PSDDescriptor.prototype.parseEnum = function() {
      this.parseID();
      return this.parseID();
    };

    PSDDescriptor.prototype.parseAlias = function() {
      var len;
      len = this.file.readInt();
      return this.file.read(len);
    };

    PSDDescriptor.prototype.parseFilePath = function() {
      var charBytes, len, numChars, path, pathSize, sig, _ref;
      len = this.file.readInt();
      _ref = this.file.readf("<4s2i"), sig = _ref[0], pathSize = _ref[1], numChars = _ref[2];
      charBytes = numChars * 2;
      path = this.file.read(charBytes);
      return {
        sig: sig,
        path: path
      };
    };

    PSDDescriptor.prototype.parseList = function() {
      var i, items, numItems, _i;
      numItems = this.file.readInt();
      items = [];
      for (i = _i = 0; 0 <= numItems ? _i < numItems : _i > numItems; i = 0 <= numItems ? ++_i : --_i) {
        items.push(this.parseItem());
      }
      return items;
    };

    PSDDescriptor.prototype.parseObjectArray = function() {
      var i, item, itemsInObj, j, klass, numItems, obj, _i, _j;
      numItems = this.file.readInt();
      klass = this.parseClass();
      itemsInObj = this.file.readInt();
      obj = [];
      for (i = _i = 0; 0 <= numItems ? _i < numItems : _i > numItems; i = 0 <= numItems ? ++_i : --_i) {
        item = [];
        for (j = _j = 0; 0 <= itemsInObj ? _j < itemsInObj : _j > itemsInObj; j = 0 <= itemsInObj ? ++_j : --_j) {
          item.push(this.parseObjectArray());
        }
        obj.push(item);
      }
      return obj;
    };

    PSDDescriptor.prototype.parseObjectArray = function() {
      var i, id, num, type, unitID, values, _i;
      id = this.parseID();
      type = this.file.readString(4);
      unitID = this.file.readString();
      num = this.file.readInt();
      values = [];
      for (i = _i = 0; 0 <= num ? _i < num : _i > num; i = 0 <= num ? ++_i : --_i) {
        values.push(this.file.readDouble());
      }
      return values;
    };

    PSDDescriptor.prototype.parseRawData = function() {
      var len;
      len = this.file.readInt();
      return this.file.read(len);
    };

    PSDDescriptor.prototype.parseReference = function() {
      var form, klass, value;
      form = this.file.readString(4);
      klass = this.parseClass();
      value = (function() {
        switch (form) {
          case "Clss":
            return null;
          case "Enmr":
            return this.parseEnum();
          case "Idnt":
            return this.parseIdentifier();
          case "indx":
            return this.parseIndex();
          case "name":
            return this.file.readUnicodeString();
          case "rele":
            return this.parseOffset();
          case "prop":
            return this.parseProperty();
        }
      }).call(this);
      return value;
    };

    PSDDescriptor.prototype.parseUnitDouble = function() {
      var unit, unitID, value;
      unitID = this.file.readString(4);
      unit = (function() {
        switch (unitID) {
          case "#Ang":
            return "Angle";
          case "#Rsl":
            return "Density";
          case "#Rlt":
            return "Distance";
          case "#Nne":
            return "None";
          case "#Prc":
            return "Percent";
          case "#Pxl":
            return "Pixels";
          case "#Mlm":
            return "Millimeters";
          case "#Pnt":
            return "Points";
        }
      })();
      value = this.file.readDouble();
      return {
        id: unitID,
        unit: unit,
        value: value
      };
    };

    return PSDDescriptor;

  })();

  PSDFile = (function() {

    PSDFile.prototype.unicodeRegex = /\\u([\d\w]{4})/gi;

    function PSDFile(data) {
      this.data = data;
      this.pos = 0;
    }

    PSDFile.prototype.tell = function() {
      return this.pos;
    };

    PSDFile.prototype.read = function(bytes) {
      var i, _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= bytes ? _i < bytes : _i > bytes; i = 0 <= bytes ? ++_i : --_i) {
        _results.push(this.data[this.pos++]);
      }
      return _results;
    };

    PSDFile.prototype.seek = function(amount, rel) {
      if (rel == null) {
        rel = true;
      }
      if (rel) {
        return this.pos += amount;
      } else {
        return this.pos = amount;
      }
    };

    PSDFile.prototype.readInt = function() {
      var int;
      int = this.readUInt();
      if (int >= 0x80000000) {
        return int - 0x100000000;
      } else {
        return int;
      }
    };

    PSDFile.prototype.readUInt = function() {
      var b1, b2, b3, b4;
      b1 = this.read(1)[0] << 24;
      b2 = this.read(1)[0] << 16;
      b3 = this.read(1)[0] << 8;
      b4 = this.read(1)[0];
      return b1 | b2 | b3 | b4;
    };

    PSDFile.prototype.readShortInt = function() {
      var int;
      int = this.readShortUInt();
      if (int >= 0x8000) {
        return int - 0x10000;
      } else {
        return int;
      }
    };

    PSDFile.prototype.readShortUInt = function() {
      var b1, b2;
      b1 = this.read(1)[0] << 8;
      b2 = this.read(1)[0];
      return b1 | b2;
    };

    PSDFile.prototype.readLongInt = function() {
      return this.readf(">l")[0];
    };

    PSDFile.prototype.readLongUInt = function() {
      return this.readf(">L")[0];
    };

    PSDFile.prototype.readDouble = function() {
      return this.readf(">d")[0];
    };

    PSDFile.prototype.readBoolean = function() {
      return this.read(1)[0] !== 0;
    };

    PSDFile.prototype.readLongLong = function() {
      return this.read(8);
    };

    PSDFile.prototype.readULongLong = function() {
      return this.read(8);
    };

    PSDFile.prototype.readString = function(length) {
      var ret;
      ret = String.fromCharCode.apply(null, this.read(length));
      return ret.replace(/\u0000/g, "");
    };

    PSDFile.prototype.readUnicodeString = function() {
      var len, str;
      len = this.readInt() * 2;
      str = this.readf(">" + len + "s")[0];
      str = str.replace(this.unicodeRegex, function(match, grp) {
        return String.fromCharCode(parseInt(grp, 16));
      });
      return str.replace(/\u0000/g, "");
    };

    PSDFile.prototype.readLengthWithString = function(defaultLen) {
      var length, str;
      if (defaultLen == null) {
        defaultLen = 4;
      }
      length = this.read(1)[0];
      if (length === 0) {
        str = this.readString(defaultLen);
      } else {
        str = this.readString(length);
      }
      return str;
    };

    PSDFile.prototype.readBytesList = function(size) {
      return this.read(size);
    };

    PSDFile.prototype.readSpaceColor = function() {
      var colorComponent, colorSpace, i, _i;
      colorSpace = this.readShortInt();
      colorComponent = [];
      for (i = _i = 0; _i < 4; i = ++_i) {
        colorComponent.push(this.readShortInt() >> 8);
      }
      return PSDColor.colorSpaceToARGB(colorSpace, colorComponent);
    };

    PSDFile.prototype.readf = function(format) {
      return jspack.Unpack(format, this.read(jspack.CalcLength(format)));
    };

    PSDFile.prototype.skipBlock = function(desc) {
      var n;
      if (desc == null) {
        desc = "unknown";
      }
      n = this.readf('>L')[0];
      if (n) {
        this.seek(n);
      }
      return Log.debug("Skipped " + desc + " with " + n + " bytes");
    };

    return PSDFile;

  })();

  PSDHeader = (function() {
    var HEADER_SECTIONS, MODES;

    HEADER_SECTIONS = ["sig", "version", "r0", "r1", "r2", "r3", "r4", "r5", "channels", "rows", "cols", "depth", "mode"];

    MODES = {
      0: 'Bitmap',
      1: 'GrayScale',
      2: 'IndexedColor',
      3: 'RGBColor',
      4: 'CMYKColor',
      5: 'HSLColor',
      6: 'HSBColor',
      7: 'Multichannel',
      8: 'Duotone',
      9: 'LabColor',
      10: 'Gray16',
      11: 'RGB48',
      12: 'Lab48',
      13: 'CMYK64',
      14: 'DeepMultichannel',
      15: 'Duotone16'
    };

    function PSDHeader(file) {
      this.file = file;
    }

    PSDHeader.prototype.parse = function() {
      var data, section, _i, _len, _ref;
      data = this.file.readf(">4sH 6B HLLHH");
      for (_i = 0, _len = HEADER_SECTIONS.length; _i < _len; _i++) {
        section = HEADER_SECTIONS[_i];
        this[section] = data.shift();
      }
      this.size = [this.rows, this.cols];
      if (this.sig !== "8BPS") {
        throw "Not a PSD signature: " + this.sig;
      }
      if (this.version !== 1) {
        throw "Can not handle PSD version " + this.version;
      }
      if ((0 <= (_ref = this.mode) && _ref < 16)) {
        this.modename = MODES[this.mode];
      } else {
        this.modename = "(" + this.mode + ")";
      }
      this.colormodepos = this.file.pos;
      return this.file.skipBlock("color mode data");
    };

    PSDHeader.prototype.toJSON = function() {
      var data, section, _i, _len;
      data = {};
      for (_i = 0, _len = HEADER_SECTIONS.length; _i < _len; _i++) {
        section = HEADER_SECTIONS[_i];
        data[section] = this[section];
      }
      data.modename = this.modename;
      return data;
    };

    return PSDHeader;

  })();

  PSDImage = (function() {
    var COMPRESSIONS;

    COMPRESSIONS = {
      0: 'Raw',
      1: 'RLE',
      2: 'ZIP',
      3: 'ZIPPrediction'
    };

    PSDImage.prototype.channelsInfo = [
      {
        id: 0
      }, {
        id: 1
      }, {
        id: 2
      }, {
        id: -1
      }
    ];

    function PSDImage(file, header) {
      this.file = file;
      this.header = header;
      this.numPixels = this.getImageWidth() * this.getImageHeight();
      if (this.getImageDepth() === 16) {
        this.numPixels *= 2;
      }
      this.calculateLength();
      this.channelData = new Uint8Array(this.length);
      this.startPos = this.file.tell();
      this.endPos = this.startPos + this.length;
      this.pixelData = [];
    }

    PSDImage.prototype.calculateLength = function() {
      this.length = (function() {
        switch (this.getImageDepth()) {
          case 1:
            return (this.getImageWidth() + 7) / 8 * this.getImageHeight();
          case 16:
            return this.getImageWidth() * this.getImageHeight() * 2;
          default:
            return this.getImageWidth() * this.getImageHeight();
        }
      }).call(this);
      this.channelLength = this.length;
      return this.length *= this.getImageChannels();
    };

    PSDImage.prototype.parse = function() {
      var _ref;
      this.compression = this.parseCompression();
      Log.debug("Image size: " + this.length + " (" + (this.getImageWidth()) + "x" + (this.getImageHeight()) + ")");
      if ((_ref = this.compression) === 2 || _ref === 3) {
        Log.debug("ZIP compression not implemented yet, skipping.");
        return this.file.seek(this.endPos, false);
      }
      return this.parseImageData();
    };

    PSDImage.prototype.skip = function() {
      Log.debug("Skipping image data");
      return this.file.seek(this.length);
    };

    PSDImage.prototype.parseCompression = function() {
      return this.file.readShortInt();
    };

    PSDImage.prototype.parseImageData = function() {
      Log.debug("Image compression: id=" + this.compression + ", name=" + COMPRESSIONS[this.compression]);
      switch (this.compression) {
        case 0:
          this.parseRaw();
          break;
        case 1:
          this.parseRLE();
          break;
        case 2:
        case 3:
          this.parseZip();
          break;
        default:
          Log.debug("Unknown image compression. Attempting to skip.");
          return this.file.seek(this.endPos, false);
      }
      return this.processImageData();
    };

    PSDImage.prototype.parseRaw = function(length) {
      var i, _i;
      if (length == null) {
        length = this.length;
      }
      Log.debug("Attempting to parse RAW encoded image...");
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        this.channelData[i] = this.file.read(1)[0];
      }
      return true;
    };

    PSDImage.prototype.parseRLE = function() {
      Log.debug("Attempting to parse RLE encoded image...");
      this.byteCounts = this.getByteCounts();
      Log.debug("Read byte counts. Current pos = " + (this.file.tell()) + ", Pixels = " + this.length);
      return this.parseChannelData();
    };

    PSDImage.prototype.getImageHeight = function() {
      return this.header.rows;
    };

    PSDImage.prototype.getImageWidth = function() {
      return this.header.cols;
    };

    PSDImage.prototype.getImageChannels = function() {
      return this.header.channels;
    };

    PSDImage.prototype.getImageDepth = function() {
      return this.header.depth;
    };

    PSDImage.prototype.getByteCounts = function() {
      var byteCounts, i, j, _i, _j, _ref, _ref1;
      byteCounts = [];
      for (i = _i = 0, _ref = this.getImageChannels(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        for (j = _j = 0, _ref1 = this.getImageHeight(); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          byteCounts.push(this.file.readShortInt());
        }
      }
      return byteCounts;
    };

    PSDImage.prototype.parseChannelData = function() {
      var chanPos, i, lineIndex, _i, _ref, _ref1;
      chanPos = 0;
      lineIndex = 0;
      for (i = _i = 0, _ref = this.getImageChannels(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        Log.debug("Parsing channel #" + i + ", Start = " + (this.file.tell()));
        _ref1 = this.decodeRLEChannel(chanPos, lineIndex), chanPos = _ref1[0], lineIndex = _ref1[1];
      }
      return true;
    };

    PSDImage.prototype.decodeRLEChannel = function(chanPos, lineIndex) {
      var byteCount, data, dataIndex, j, k, len, start, val, z, _i, _j, _k, _l, _ref, _ref1, _ref2;
      for (j = _i = 0, _ref = this.getImageHeight(); 0 <= _ref ? _i < _ref : _i > _ref; j = 0 <= _ref ? ++_i : --_i) {
        byteCount = this.byteCounts[lineIndex++];
        start = this.file.tell();
        while (this.file.tell() < start + byteCount) {
          len = this.file.read(1)[0];
          if (len < 128) {
            len++;
            data = this.file.read(len);
            dataIndex = 0;
            for (k = _j = chanPos, _ref1 = chanPos + len; chanPos <= _ref1 ? _j < _ref1 : _j > _ref1; k = chanPos <= _ref1 ? ++_j : --_j) {
              this.channelData[k] = data[dataIndex++];
            }
            chanPos += len;
          } else if (len > 128) {
            len ^= 0xff;
            len += 2;
            val = this.file.read(1)[0];
            data = [];
            for (z = _k = 0; 0 <= len ? _k < len : _k > len; z = 0 <= len ? ++_k : --_k) {
              data.push(val);
            }
            dataIndex = 0;
            for (k = _l = chanPos, _ref2 = chanPos + len; chanPos <= _ref2 ? _l < _ref2 : _l > _ref2; k = chanPos <= _ref2 ? ++_l : --_l) {
              this.channelData[k] = data[dataIndex++];
            }
            chanPos += len;
          }
        }
      }
      return [chanPos, lineIndex];
    };

    PSDImage.prototype.parseZip = function(prediction) {
      if (prediction == null) {
        prediction = false;
      }
      return this.file.seek(this.endPos, false);
    };

    PSDImage.prototype.processImageData = function() {
      Log.debug("Processing parsed image data. " + this.channelData.length + " pixels read.");
      switch (this.header.mode) {
        case 1:
          if (this.getImageDepth() === 8) {
            this.combineGreyscale8Channel();
          }
          if (this.getImageDepth() === 16) {
            this.combineGreyscale16Channel();
          }
          break;
        case 3:
          if (this.getImageDepth() === 8) {
            this.combineRGB8Channel();
          }
          if (this.getImageDepth() === 16) {
            this.combineRGB16Channel();
          }
          break;
        case 4:
          if (this.getImageDepth() === 8) {
            this.combineCMYK8Channel();
          }
          if (this.getImageDepth() === 16) {
            this.combineCMYK16Channel();
          }
          break;
        case 7:
          this.combineMultiChannel8();
          break;
        case 9:
          if (this.getImageDepth() === 8) {
            this.combineLAB8Channel();
          }
          if (this.getImageDepth() === 16) {
            this.combineLAB16Channel();
          }
      }
      return delete this.channelData;
    };

    PSDImage.prototype.getAlphaValue = function(alpha) {
      if (alpha == null) {
        alpha = 255;
      }
      if (this.layer != null) {
        alpha = alpha * (this.layer.blendMode.opacity / 255);
      }
      return alpha;
    };

    PSDImage.prototype.combineGreyscale8Channel = function() {
      var alpha, grey, i, _i, _j, _ref, _ref1, _results, _results1;
      if (this.getImageChannels() === 2) {
        _results = [];
        for (i = _i = 0, _ref = this.numPixels; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          alpha = this.channelData[i];
          grey = this.channelData[this.channelLength + i];
          _results.push(this.pixelData.push(grey, grey, grey, this.getAlphaValue(alpha)));
        }
        return _results;
      } else {
        _results1 = [];
        for (i = _j = 0, _ref1 = this.numPixels; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          _results1.push(this.pixelData.push(this.channelData[i], this.channelData[i], this.channelData[i], this.getAlphaValue()));
        }
        return _results1;
      }
    };

    PSDImage.prototype.combineGreyscale16Channel = function() {
      var alpha, grey, i, pixel, _i, _j, _ref, _ref1, _results, _results1;
      if (this.getImageChannels() === 2) {
        _results = [];
        for (i = _i = 0, _ref = this.numPixels; _i < _ref; i = _i += 2) {
          alpha = Util.toUInt16(this.channelData[i + 1], this.channelData[i]);
          grey = Util.toUInt16(this.channelData[this.channelLength + i + 1], this.channelData[this.channelLength + i]);
          _results.push(this.pixelData.push(grey, grey, grey, this.getAlphaValue(alpha)));
        }
        return _results;
      } else {
        _results1 = [];
        for (i = _j = 0, _ref1 = this.numPixels; _j < _ref1; i = _j += 2) {
          pixel = Util.toUInt16(this.channelData[i + 1], this.channelData[i]);
          _results1.push(this.pixelData.push(pixel, pixel, pixel, this.getAlphaValue()));
        }
        return _results1;
      }
    };

    PSDImage.prototype.combineRGB8Channel = function() {
      var chan, i, index, pixel, _i, _j, _len, _ref, _ref1, _results;
      _results = [];
      for (i = _i = 0, _ref = this.numPixels; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        index = 0;
        pixel = {
          r: 0,
          g: 0,
          b: 0,
          a: 255
        };
        _ref1 = this.channelsInfo;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          chan = _ref1[_j];
          switch (chan.id) {
            case -1:
              if (this.getImageChannels() === 4) {
                pixel.a = this.channelData[i + (this.channelLength * index)];
              } else {
                continue;
              }
              break;
            case 0:
              pixel.r = this.channelData[i + (this.channelLength * index)];
              break;
            case 1:
              pixel.g = this.channelData[i + (this.channelLength * index)];
              break;
            case 2:
              pixel.b = this.channelData[i + (this.channelLength * index)];
          }
          index++;
        }
        _results.push(this.pixelData.push(pixel.r, pixel.g, pixel.b, this.getAlphaValue(pixel.a)));
      }
      return _results;
    };

    PSDImage.prototype.combineRGB16Channel = function() {
      var b1, b2, chan, i, index, pixel, _i, _j, _len, _ref, _ref1, _results;
      _results = [];
      for (i = _i = 0, _ref = this.numPixels; _i < _ref; i = _i += 2) {
        index = 0;
        pixel = {
          r: 0,
          g: 0,
          b: 0,
          a: 255
        };
        _ref1 = this.channelsInfo;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          chan = _ref1[_j];
          b1 = this.channelData[i + (this.channelLength * index) + 1];
          b2 = this.channelData[i + (this.channelLength * index)];
          switch (chan.id) {
            case -1:
              if (this.getImageChannels() === 4) {
                pixel.a = Util.toUInt16(b1, b2);
              } else {
                continue;
              }
              break;
            case 0:
              pixel.r = Util.toUInt16(b1, b2);
              break;
            case 1:
              pixel.g = Util.toUInt16(b1, b2);
              break;
            case 2:
              pixel.b = Util.toUInt16(b1, b2);
          }
          index++;
        }
        _results.push(this.pixelData.push(pixel.r, pixel.g, pixel.b, this.getAlphaValue(pixel.a)));
      }
      return _results;
    };

    PSDImage.prototype.combineCMYK8Channel = function() {
      var a, c, i, k, m, rgb, y, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.numPixels; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (this.getImageChannels() === 5) {
          a = this.channelData[i];
          c = this.channelData[i + this.channelLength];
          m = this.channelData[i + this.channelLength * 2];
          y = this.channelData[i + this.channelLength * 3];
          k = this.channelData[i + this.channelLength * 4];
        } else {
          a = 255;
          c = this.channelData[i];
          m = this.channelData[i + this.channelLength];
          y = this.channelData[i + this.channelLength * 2];
          k = this.channelData[i + this.channelLength * 3];
        }
        rgb = PSDColor.cmykToRGB(255 - c, 255 - m, 255 - y, 255 - k);
        _results.push(this.pixelData.push(rgb.r, rgb.g, rgb.b, this.getAlphaValue(a)));
      }
      return _results;
    };

    PSDImage.prototype.combineCMYK16Channel = function() {
      var a, c, i, k, m, rgb, y, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.numPixels; _i < _ref; i = _i += 2) {
        if (this.getImageChannels() === 5) {
          a = this.channelData[i];
          c = this.channelData[i + this.channelLength];
          m = this.channelData[i + this.channelLength * 2];
          y = this.channelData[i + this.channelLength * 3];
          k = this.channelData[i + this.channelLength * 3];
        } else {
          a = 255;
          c = this.channelData[i];
          m = this.channelData[i + this.channelLength];
          y = this.channelData[i + this.channelLength * 2];
          k = this.channelData[i + this.channelLength * 3];
        }
        rgb = PSDColor.cmykToRGB(255 - c, 255 - m, 255 - y, 255 - k);
        _results.push(this.pixelData.push(rgb.r, rgb.g, rgb.b, this.getAlphaValue(a)));
      }
      return _results;
    };

    PSDImage.prototype.combineLAB8Channel = function() {
      var a, alpha, b, i, l, rgb, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.numPixels; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (this.getImageChannels() === 4) {
          alpha = this.channelData[i];
          l = this.channelData[i + this.channelLength];
          a = this.channelData[i + this.channelLength * 2];
          b = this.channelData[i + this.channelLength * 3];
        } else {
          alpha = 255;
          l = this.channelData[i];
          a = this.channelData[i + this.channelLength];
          b = this.channelData[i + this.channelLength * 2];
        }
        rgb = PSDColor.labToRGB(l * 100 >> 8, a - 128, b - 128);
        _results.push(this.pixelData.push(rgb.r, rgb.g, rgb.b, this.getAlphaValue(alpha)));
      }
      return _results;
    };

    PSDImage.prototype.combineLAB16Channel = function() {
      var a, alpha, b, i, l, rgb, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.numPixels; _i < _ref; i = _i += 2) {
        if (this.getImageChannels() === 4) {
          alpha = this.channelData[i];
          l = this.channelData[i + this.channelLength];
          a = this.channelData[i + this.channelLength * 2];
          b = this.channelData[i + this.channelLength * 3];
        } else {
          alpha = 255;
          l = this.channelData[i];
          a = this.channelData[i + this.channelLength];
          b = this.channelData[i + this.channelLength * 2];
        }
        rgb = PSDColor.labToRGB(l * 100 >> 8, a - 128, b - 128);
        _results.push(this.pixelData.push(rgb.r, rgb.g, rgb.b, this.getAlphaValue(alpha)));
      }
      return _results;
    };

    PSDImage.prototype.combineMultiChannel8 = function() {
      var c, i, k, m, rgb, y, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.numPixels; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        c = this.channelData[i];
        m = this.channelData[i + this.channelLength];
        y = this.channelData[i + this.channelLength * 2];
        if (this.getImageChannels() === 4) {
          k = this.channelData[i + this.channelLength * 3];
        } else {
          k = 255;
        }
        rgb = PSDColor.cmykToRGB(255 - c, 255 - m, 255 - y, 255 - k);
        _results.push(this.pixelData.push(rgb.r, rgb.g, rgb.b, this.getAlphaValue(255)));
      }
      return _results;
    };

    PSDImage.prototype.toCanvasPixels = function() {
      return this.pixelData;
    };

    PSDImage.prototype.toFile = function(filename, cb) {
      var png;
      if (this.toCanvasPixels().length === 0) {
        return cb();
      }
      png = this.getPng();
      if (png === null) {
        return cb();
      }
      return png.encode(function(image) {
        return fs.writeFile(filename, image, cb);
      });
    };

    PSDImage.prototype.toFileSync = function(filename) {
      var image, png;
      if (this.toCanvasPixels().length === 0) {
        return;
      }
      png = this.getPng();
      if (png === null) {
        return;
      }
      image = png.encodeSync();
      return fs.writeFileSync(filename, image);
    };

    PSDImage.prototype.getPng = function() {
      var Png, buffer, i, pixelData, _i, _ref;
      try {
        Png = require('png').Png;
      } catch (e) {
        throw "Exporting PSDs to file requires the node-png library";
      }
      buffer = new Buffer(this.toCanvasPixels().length);
      pixelData = this.toCanvasPixels();
      for (i = _i = 0, _ref = pixelData.length; _i < _ref; i = _i += 4) {
        buffer[i] = pixelData[i];
        buffer[i + 1] = pixelData[i + 1];
        buffer[i + 2] = pixelData[i + 2];
        buffer[i + 3] = 255 - pixelData[i + 3];
      }
      try {
        if (this.getImageWidth() !== 0 && this.getImageHeight() !== 0) {
          return new Png(buffer, this.getImageWidth(), this.getImageHeight(), 'rgba');
        } else {
          return new Png(buffer, this.header.cols, this.header.rows, 'rgba');
        }
      } catch (e) {
        Log.debug(e);
        return null;
      }
    };

    PSDImage.prototype.toCanvas = function(canvas, width, height) {
      var context, i, imageData, pixelData, pxl, _i, _len, _ref;
      if (width == null) {
        width = this.getImageWidth();
      }
      if (height == null) {
        height = this.getImageHeight();
      }
      if (!(width != null) || !(height != null) || width <= 0 || height <= 0) {
        throw "Layer does not contain image data";
      }
      canvas.width = width;
      canvas.height = height;
      context = canvas.getContext('2d');
      imageData = context.getImageData(0, 0, canvas.width, canvas.height);
      pixelData = imageData.data;
      _ref = this.toCanvasPixels();
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        pxl = _ref[i];
        pixelData[i] = pxl;
      }
      return context.putImageData(imageData, 0, 0);
    };

    PSDImage.prototype.toImage = function() {
      var canvas;
      canvas = document.createElement('canvas');
      this.toCanvas(canvas);
      return canvas.toDataURL("image/png");
    };

    return PSDImage;

  })();

  PSDChannelImage = (function(_super) {

    __extends(PSDChannelImage, _super);

    function PSDChannelImage(file, header, layer) {
      this.layer = layer;
      this.width = this.layer.cols;
      this.height = this.layer.rows;
      this.channelsInfo = this.layer.channelsInfo;
      PSDChannelImage.__super__.constructor.call(this, file, header);
    }

    PSDChannelImage.prototype.skip = function() {
      var channel, _i, _len, _ref, _results;
      Log.debug("Skipping channel image data. Layer = " + this.layer.name);
      _ref = this.channelsInfo;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        channel = _ref[_i];
        _results.push(this.file.seek(channel.length));
      }
      return _results;
    };

    PSDChannelImage.prototype.getImageWidth = function() {
      return this.width;
    };

    PSDChannelImage.prototype.getImageHeight = function() {
      return this.height;
    };

    PSDChannelImage.prototype.getImageChannels = function() {
      return this.layer.channels;
    };

    PSDChannelImage.prototype.getByteCounts = function() {
      var byteCounts, i, _i, _ref;
      byteCounts = [];
      for (i = _i = 0, _ref = this.getImageHeight(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        byteCounts.push(this.file.readShortInt());
      }
      return byteCounts;
    };

    PSDChannelImage.prototype.parse = function() {
      var end, i, memusage, start, total, used, _i, _ref;
      Log.debug("\nLayer: " + this.layer.name + ", image size: " + this.length + " (" + (this.getImageWidth()) + "x" + (this.getImageHeight()) + ")");
      this.chanPos = 0;
      for (i = _i = 0, _ref = this.getImageChannels(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.chInfo = this.layer.channelsInfo[i];
        if (this.chInfo.length <= 0) {
          this.parseCompression();
          continue;
        }
        if (this.chInfo.id === -2) {
          this.width = this.layer.mask.width;
          this.height = this.layer.mask.height;
        } else {
          this.width = this.layer.cols;
          this.height = this.layer.rows;
        }
        start = this.file.tell();
        Log.debug("Channel #" + this.chInfo.id + ": length=" + this.chInfo.length);
        this.parseImageData();
        end = this.file.tell();
        if (end !== start + this.chInfo.length) {
          Log.debug("ERROR: read incorrect number of bytes for channel #" + this.chInfo.id + ". Layer=" + this.layer.name + ", Expected = " + (start + this.chInfo.length) + ", Actual: " + end);
          this.file.seek(start + this.chInfo.length, false);
        }
      }
      if (this.channelData.length !== this.length) {
        Log.debug("ERROR: " + this.channelData.length + " read; expected " + this.length);
      }
      this.processImageData();
      if (typeof exports !== "undefined" && exports !== null) {
        memusage = process.memoryUsage();
        used = Math.round(memusage.heapUsed / 1024 / 1024);
        total = Math.round(memusage.heapTotal / 1024 / 1024);
        return Log.debug("\nMemory usage: " + used + "MB / " + total + "MB");
      }
    };

    PSDChannelImage.prototype.parseRaw = function() {
      var data, dataIndex, i, _i, _ref, _ref1;
      Log.debug("Attempting to parse RAW encoded channel...");
      data = this.file.read(this.chInfo.length - 2);
      dataIndex = 0;
      for (i = _i = _ref = this.chanPos, _ref1 = this.chanPos + this.chInfo.length - 2; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
        this.channelData[i] = data[dataIndex++];
      }
      return this.chanPos += this.chInfo.length - 2;
    };

    PSDChannelImage.prototype.parseImageData = function() {
      this.compression = this.parseCompression();
      switch (this.compression) {
        case 0:
          return this.parseRaw();
        case 1:
          return this.parseRLE();
        case 2:
        case 3:
          return this.parseZip();
        default:
          Log.debug("Unknown image compression. Attempting to skip.");
          return this.file.seek(this.endPos, false);
      }
    };

    PSDChannelImage.prototype.parseChannelData = function() {
      var lineIndex, _ref;
      lineIndex = 0;
      Log.debug("Parsing layer channel #" + this.chInfo.id + ", Start = " + (this.file.tell()));
      return _ref = this.decodeRLEChannel(this.chanPos, lineIndex), this.chanPos = _ref[0], lineIndex = _ref[1], _ref;
    };

    return PSDChannelImage;

  })(PSDImage);

  PSDLayer = (function() {
    var BLEND_FLAGS, BLEND_MODES, CHANNEL_SUFFIXES, MASK_FLAGS, SAFE_FONTS, SECTION_DIVIDER_TYPES;

    CHANNEL_SUFFIXES = {
      '-2': 'layer mask',
      '-1': 'A',
      0: 'R',
      1: 'G',
      2: 'B',
      3: 'RGB',
      4: 'CMYK',
      5: 'HSL',
      6: 'HSB',
      9: 'Lab',
      11: 'RGB',
      12: 'Lab',
      13: 'CMYK'
    };

    SECTION_DIVIDER_TYPES = {
      0: "other",
      1: "open folder",
      2: "closed folder",
      3: "bounding section divider"
    };

    BLEND_MODES = {
      "norm": "normal",
      "dark": "darken",
      "lite": "lighten",
      "hue": "hue",
      "sat": "saturation",
      "colr": "color",
      "lum": "luminosity",
      "mul": "multiply",
      "scrn": "screen",
      "diss": "dissolve",
      "over": "overlay",
      "hLit": "hard light",
      "sLit": "soft light",
      "diff": "difference",
      "smud": "exclusion",
      "div": "color dodge",
      "idiv": "color burn",
      "lbrn": "linear burn",
      "lddg": "linear dodge",
      "vLit": "vivid light",
      "lLit": "linear light",
      "pLit": "pin light",
      "hMix": "hard mix"
    };

    BLEND_FLAGS = {
      0: "transparency protected",
      1: "visible",
      2: "obsolete",
      3: "bit 4 useful",
      4: "pixel data irrelevant"
    };

    MASK_FLAGS = {
      0: "position relative",
      1: "layer mask disabled",
      2: "invert layer mask"
    };

    SAFE_FONTS = ["Arial", "Courier New", "Georgia", "Times New Roman", "Verdana", "Trebuchet MS", "Lucida Sans", "Tahoma"];

    function PSDLayer(file, header) {
      this.file = file;
      this.header = header != null ? header : null;
      this.image = null;
      this.mask = {};
      this.blendingRanges = {};
      this.adjustments = {};
      this.layerType = "normal";
      this.blendingMode = "normal";
      this.opacity = 255;
      this.isFolder = false;
      this.isHidden = false;
    }

    PSDLayer.prototype.parse = function(layerIndex) {
      var extralen, extrastart, result;
      if (layerIndex == null) {
        layerIndex = null;
      }
      this.parseInfo(layerIndex);
      this.parseBlendModes();
      extralen = this.file.readInt();
      this.layerEnd = this.file.tell() + extralen;
      assert(extralen > 0);
      extrastart = this.file.tell();
      result = this.parseMaskData();
      if (!result) {
        Log.debug("Error parsing mask data for layer #" + layerIndex + ". Skipping.");
        return this.file.seek(this.layerEnd, false);
      }
      this.parseBlendingRanges();
      this.parseLegacyLayerName();
      this.parseExtraData();
      if (this.name == null) {
        this.name = this.legacyName;
      }
      Log.debug("Layer " + layerIndex + ":", this);
      return this.file.seek(extrastart + extralen, false);
    };

    PSDLayer.prototype.parseInfo = function(layerIndex) {
      var channelID, channelLength, i, _i, _ref, _ref1, _ref2, _ref3, _results;
      this.idx = layerIndex;
      /*
          Layer Info
      */

      _ref = this.file.readf(">iiiih"), this.top = _ref[0], this.left = _ref[1], this.bottom = _ref[2], this.right = _ref[3], this.channels = _ref[4];
      _ref1 = [this.bottom - this.top, this.right - this.left], this.rows = _ref1[0], this.cols = _ref1[1];
      assert(this.channels > 0);
      this.height = this.rows;
      this.width = this.cols;
      if (this.bottom < this.top || this.right < this.left || this.channels > 64) {
        Log.debug("Somethings not right, attempting to skip layer.");
        this.file.seek(6 * this.channels + 12);
        this.file.skipBlock("layer info: extra data");
        return;
      }
      this.channelsInfo = [];
      _results = [];
      for (i = _i = 0, _ref2 = this.channels; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
        _ref3 = this.file.readf(">hi"), channelID = _ref3[0], channelLength = _ref3[1];
        Log.debug("Channel " + i + ": id=" + channelID + ", " + channelLength + " bytes, type=" + CHANNEL_SUFFIXES[channelID]);
        _results.push(this.channelsInfo.push({
          id: channelID,
          length: channelLength
        }));
      }
      return _results;
    };

    PSDLayer.prototype.parseBlendModes = function() {
      var filler, flags, _ref;
      this.blendMode = {};
      _ref = this.file.readf(">4s4sBBBB"), this.blendMode.sig = _ref[0], this.blendMode.key = _ref[1], this.blendMode.opacity = _ref[2], this.blendMode.clipping = _ref[3], flags = _ref[4], filler = _ref[5];
      assert(this.blendMode.sig === "8BIM");
      this.blendMode.key = this.blendMode.key.trim();
      this.blendMode.opacityPercentage = (this.blendMode.opacity * 100) / 255;
      this.blendMode.blender = BLEND_MODES[this.blendMode.key];
      this.blendMode.transparencyProtected = flags & 0x01;
      this.blendMode.visible = (flags & (0x01 << 1)) > 0;
      this.blendMode.visible = 1 - this.blendMode.visible;
      this.blendMode.obsolete = (flags & (0x01 << 2)) > 0;
      if ((flags & (0x01 << 3)) > 0) {
        this.blendMode.pixelDataIrrelevant = (flags & (0x01 << 4)) > 0;
      }
      this.blendingMode = this.blendMode.blender;
      this.opacity = this.blendMode.opacity;
      this.visible = this.blendMode.visible;
      return Log.debug("Blending mode:", this.blendMode);
    };

    PSDLayer.prototype.parseMaskData = function() {
      var flags, _ref, _ref1, _ref2, _ref3;
      this.mask.size = this.file.readInt();
      assert((_ref = this.mask.size) === 36 || _ref === 20 || _ref === 0);
      if (this.mask.size === 0) {
        return true;
      }
      _ref1 = this.file.readf(">llllBB"), this.mask.top = _ref1[0], this.mask.left = _ref1[1], this.mask.bottom = _ref1[2], this.mask.right = _ref1[3], this.mask.defaultColor = _ref1[4], flags = _ref1[5];
      assert((_ref2 = this.mask.defaultColor) === 0 || _ref2 === 255);
      this.mask.width = this.mask.right - this.mask.left;
      this.mask.height = this.mask.bottom - this.mask.top;
      this.mask.relative = flags & 0x01;
      this.mask.disabled = (flags & (0x01 << 1)) > 0;
      this.mask.invert = (flags & (0x01 << 2)) > 0;
      if (this.mask.size === 20) {
        this.file.seek(2);
      } else {
        _ref3 = this.file.readf(">BB"), flags = _ref3[0], this.mask.defaultColor = _ref3[1];
        this.mask.relative = flags & 0x01;
        this.mask.disabled = (flags & (0x01 << 1)) > 0;
        this.mask.invert = (flags & (0x01 << 2)) > 0;
        this.file.seek(16);
      }
      return true;
    };

    PSDLayer.prototype.parseBlendingRanges = function() {
      var i, length, pos, _i, _ref, _results;
      length = this.file.readInt();
      this.blendingRanges.grey = {
        source: {
          black: this.file.readShortInt(),
          white: this.file.readShortInt()
        },
        dest: {
          black: this.file.readShortInt(),
          white: this.file.readShortInt()
        }
      };
      pos = this.file.tell();
      this.blendingRanges.numChannels = (length - 8) / 8;
      assert(this.blendingRanges.numChannels > 0);
      this.blendingRanges.channels = [];
      _results = [];
      for (i = _i = 0, _ref = this.blendingRanges.numChannels; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(this.blendingRanges.channels.push({
          source: {
            black: this.file.readShortInt(),
            white: this.file.readShortInt()
          },
          dest: {
            black: this.file.readShortInt(),
            white: this.file.readShortInt()
          }
        }));
      }
      return _results;
    };

    PSDLayer.prototype.parseLegacyLayerName = function() {
      var namelen;
      namelen = Util.pad4(this.file.read(1)[0]);
      return this.legacyName = Util.decodeMacroman(this.file.read(namelen)).replace(/\u0000/g, '');
    };

    PSDLayer.prototype.parseExtraData = function() {
      var key, legacyEffects, length, pos, signature, _ref, _results;
      _results = [];
      while (this.file.tell() < this.layerEnd) {
        _ref = this.file.readf(">4s4s"), signature = _ref[0], key = _ref[1];
        assert.equal(signature, "8BIM");
        length = Util.pad2(this.file.readInt());
        pos = this.file.tell();
        Log.debug("Extra layer info: key = " + key + ", length = " + length);
        switch (key) {
          case "SoCo":
            this.adjustments.solidColor = (new PSDSolidColor(this, length)).parse();
            break;
          case "GdFl":
            this.adjustments.gradient = (new PSDGradient(this, length)).parse();
            break;
          case "PtFl":
            this.adjustments.pattern = (new PSDPattern(this, length)).parse();
            break;
          case "brit":
            this.adjustments.brightnessContrast = (new PSDBrightnessContrast(this, length)).parse();
            break;
          case "levl":
            this.adjustments.levels = (new PSDLevels(this, length)).parse();
            break;
          case "curv":
            this.adjustments.curves = (new PSDCurves(this, length)).parse();
            break;
          case "expA":
            this.adjustments.exposure = (new PSDExposure(this, length)).parse();
            break;
          case "vibA":
            this.adjustments.vibrance = (new PSDVibrance(this, length)).parse();
            break;
          case "hue2":
            this.adjustments.hueSaturation = (new PSDHueSaturation(this, length)).parse();
            break;
          case "blnc":
            this.adjustments.colorBalance = (new PSDColorBalance(this, length)).parse();
            break;
          case "blwh":
            this.adjustments.blackWhite = (new PSDBlackWhite(this, length)).parse();
            break;
          case "phfl":
            this.adjustments.photoFilter = (new PSDPhotoFilter(this, length)).parse();
            break;
          case "thrs":
            this.adjustments.threshold = (new PSDThreshold(this, length)).parse();
            break;
          case "nvrt":
            this.adjustments.invert = (new PSDInvert(this, length)).parse();
            break;
          case "post":
            this.adjustments.posterize = (new PSDPosterize(this, length)).parse();
            break;
          case "tySh":
            this.adjustments.typeTool = (new PSDTypeTool(this, length)).parse(true);
            break;
          case "TySh":
            this.adjustments.typeTool = (new PSDTypeTool(this, length)).parse();
            break;
          case "luni":
            this.name = this.file.readUnicodeString();
            this.file.seek(pos + length, false);
            break;
          case "lyid":
            this.layerId = this.file.readInt();
            break;
          case "lsct":
            this.readLayerSectionDivider();
            break;
          case "lrFX":
            legacyEffects = (new PSDEffectsInfo(this, length)).parseLegacy();
            this.file.read(2);
            break;
          case "lfx2":
            this.adjustments.effects = (new PSDEffectsInfo(this, length)).parse();
            break;
          case "selc":
            this.adjustments.selectiveColor = (new PSDSelectiveColor(this, length)).parse();
            break;
          default:
            this.file.seek(length);
            Log.debug("Skipping additional layer info with key " + key);
        }
        if (this.file.tell() !== (pos + length)) {
          Log.debug("Warning: additional layer info with key " + key + " - unexpected end. Position = " + (this.file.tell()) + ", Expected = " + (pos + length));
          _results.push(this.file.seek(pos + length, false));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    PSDLayer.prototype.readLayerSectionDivider = function() {
      var code;
      code = this.file.readInt();
      this.layerType = SECTION_DIVIDER_TYPES[code];
      Log.debug("Layer type:", this.layerType);
      switch (code) {
        case 1:
        case 2:
          return this.isFolder = true;
        case 3:
          return this.isHidden = true;
      }
    };

    PSDLayer.prototype.toJSON = function() {
      var data, section, sections, _i, _len;
      this.bounds = {
        'top': this.top,
        'bottom': this.bottom,
        'left': this.left,
        'right': this.right
      };
      if (this.blendMode.clipping === 0) {
        this.clipping = false;
      } else {
        this.clipping = true;
      }
      this.opacityPercentage = this.blendMode.opacityPercentage;
      sections = ['layerId', 'name', 'rows', 'cols', 'bounds', 'layerType', 'opacityPercentage', 'clipping', 'adjustments', 'visible', 'isFolder', 'isHidden'];
      data = {};
      for (_i = 0, _len = sections.length; _i < _len; _i++) {
        section = sections[_i];
        data[section] = this[section];
      }
      return data;
    };

    return PSDLayer;

  })();

  PSDLayerMask = (function() {

    function PSDLayerMask(file, header, options) {
      this.file = file;
      this.header = header;
      this.options = options;
      this.layers = [];
      this.mergedAlpha = false;
      this.globalMask = {};
      this.extras = [];
    }

    PSDLayerMask.prototype.skip = function() {
      return this.file.seek(this.file.readInt());
    };

    PSDLayerMask.prototype.parse = function() {
      var endLoc, flag, i, layer, layerInfoSize, maskSize, pos, skip_count, _i, _j, _len, _ref, _ref1;
      maskSize = this.file.readInt();
      endLoc = this.file.tell() + maskSize;
      Log.debug("Layer mask size is " + maskSize);
      if (maskSize <= 0) {
        return;
      }
      layerInfoSize = Util.pad2(this.file.readInt());
      flag = true;
      if (layerInfoSize !== 0) {
        flag = false;
      }
      skip_count = 0;
      while (flag) {
        skip_count++;
        layerInfoSize = this.file.readInt();
        if (layerInfoSize !== 0 && layerInfoSize < maskSize) {
          flag = false;
        }
      }
      if (skip_count > 0) {
        console.log("Skipped " + skip_count + " times...");
      }
      pos = this.file.tell();
      if (layerInfoSize > 0) {
        this.numLayers = this.file.readShortInt();
        if (this.numLayers < 0) {
          Log.debug("Note: first alpha channel contains transparency data");
          this.numLayers = Math.abs(this.numLayers);
          this.mergedAlpha = true;
        }
        if (this.numLayers * (18 + 6 * this.header.channels) > layerInfoSize) {
          throw "Unlikely number of " + this.numLayers + " layers for " + this.header['channels'] + " with " + layerInfoSize + " layer info size. Giving up.";
        }
        Log.debug("Found " + this.numLayers + " layer(s)");
        for (i = _i = 0, _ref = this.numLayers; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          layer = new PSDLayer(this.file);
          layer.parse(i);
          this.layers.push(layer);
        }
        _ref1 = this.layers;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          layer = _ref1[_j];
          if (layer.isFolder || layer.isHidden) {
            this.file.seek(8);
            continue;
          }
          layer.image = new PSDChannelImage(this.file, this.header, layer);
          if (this.options.layerImages && ((this.options.onlyVisibleLayers && layer.visible) || !this.options.onlyVisibleLayers)) {
            layer.image.parse();
          } else {
            layer.image.skip();
          }
        }
        this.layers.reverse();
        this.groupLayers();
      }
      this.file.seek(pos + layerInfoSize, false);
      this.parseGlobalMask();
      this.file.seek(endLoc, false);
      return;
      if (this.file.tell() < endLoc) {
        return this.parseExtraInfo(endLoc);
      }
    };

    PSDLayerMask.prototype.parseGlobalMask = function() {
      var end, i, length, start, _i;
      length = this.file.readInt();
      if (length === 0) {
        return;
      }
      start = this.file.tell();
      end = this.file.tell() + length;
      Log.debug("Global mask length: " + length);
      this.globalMask.overlayColorSpace = this.file.readShortInt();
      this.globalMask.colorComponents = [];
      for (i = _i = 0; _i < 4; i = ++_i) {
        this.globalMask.colorComponents.push(this.file.readShortInt() >> 8);
      }
      this.globalMask.opacity = this.file.readShortInt();
      this.globalMask.kind = this.file.read(1)[0];
      Log.debug("Global mask:", this.globalMask);
      return this.file.seek(end, false);
    };

    PSDLayerMask.prototype.parseExtraInfo = function(end) {
      var key, length, sig, _ref, _results;
      _results = [];
      while (this.file.tell() < end) {
        _ref = this.file.readf(">4s4sI"), sig = _ref[0], key = _ref[1], length = _ref[2];
        length = Util.pad2(length);
        console.log("Layer extra:", sig, key, length);
        _results.push(this.file.seek(length));
      }
      return _results;
    };

    PSDLayerMask.prototype.groupLayers = function() {
      var groupLayer, layer, _i, _len, _ref, _results;
      groupLayer = null;
      _ref = this.layers;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        layer = _ref[_i];
        if (layer.isFolder) {
          _results.push(groupLayer = layer);
        } else if (layer.isHidden) {
          _results.push(groupLayer = null);
        } else {
          _results.push(layer.groupLayer = groupLayer);
        }
      }
      return _results;
    };

    PSDLayerMask.prototype.toJSON = function() {
      var data, layer, _i, _len, _ref;
      data = {
        mergedAlpha: this.mergedAlpha,
        globalMask: this.globalMask,
        extraInfo: this.extras,
        numLayers: this.numLayers,
        layers: []
      };
      _ref = this.layers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        layer = _ref[_i];
        data.layers.push(layer.toJSON());
      }
      return data;
    };

    return PSDLayerMask;

  })();

  EngineDataParser = (function() {

    function EngineDataParser() {}

    EngineDataParser.parseData = function(data) {
      var root, tokens;
      data = data.replace(/(\r\n|\n|\r)/gm, ' ');
      data = data.replace(/\s{2,}/g, ' ');
      tokens = data.split(' ');
      root = {};
      EngineDataParser.parseTokens(tokens, root);
      return root;
    };

    EngineDataParser.parseTokens = function(tokens, parent, parent_is_array) {
      var currentToken;
      if (parent_is_array == null) {
        parent_is_array = false;
      }
      while (tokens[0] === "") {
        tokens.splice(0, 1);
      }
      currentToken = tokens[0];
      if (currentToken === ">>" && !parent_is_array) {

      }
    };

    return EngineDataParser;

  })();

  PSDBlackWhite = (function() {

    function PSDBlackWhite(layer, length) {
      this.layer = layer;
      this.length = length;
      this.file = this.layer.file;
    }

    PSDBlackWhite.prototype.parse = function() {
      var version;
      version = this.file.readInt();
      assert(version === 16);
      return (new PSDDescriptor(this.file)).parse();
    };

    return PSDBlackWhite;

  })();

  PSDBrightnessContrast = (function() {

    function PSDBrightnessContrast(layer, length) {
      this.layer = layer;
      this.length = length;
      this.file = this.layer.file;
      this.data = {};
    }

    PSDBrightnessContrast.prototype.parse = function() {
      this.data.brightness = this.file.getShortInt();
      this.data.contrast = this.file.getShortInt();
      this.data.meanValue = this.file.getShortInt();
      this.data.labColor = this.file.getShortInt();
      return this.data;
    };

    return PSDBrightnessContrast;

  })();

  PSDColorBalance = (function() {

    function PSDColorBalance(layer, length) {
      this.layer = layer;
      this.length = length;
      this.file = this.layer.file;
      this.data = {
        cyanRed: [],
        magentaGreen: [],
        yellowBlue: []
      };
    }

    PSDColorBalance.prototype.parse = function() {
      var i, _i;
      for (i = _i = 0; _i < 3; i = ++_i) {
        this.data.cyanRed.push(this.file.getShortInt());
        this.data.magentaGreen.push(this.file.getShortInt());
        this.data.yellowBlue.push(this.file.getShortInt());
      }
      return this.data;
    };

    return PSDColorBalance;

  })();

  PSDCurves = (function() {

    function PSDCurves(layer, length) {
      this.layer = layer;
      this.length = length;
      this.file = this.layer.file;
      this.data = {
        curve: []
      };
    }

    PSDCurves.prototype.parse = function() {
      var count, curveCount, i, inputValue, j, outputValue, pointCount, start, tag, version, _i, _j, _k, _l, _m, _n, _ref, _ref1, _ref2;
      start = this.file.tell();
      this.file.seek(1);
      version = this.file.readShortInt();
      assert(version === 1 || version === 4);
      tag = this.file.readInt();
      this.data.curveCount = 0;
      for (i = _i = 0; _i < 32; i = ++_i) {
        if (tag & (1 << i)) {
          this.data.curveCount++;
        }
      }
      for (i = _j = 0, _ref = this.data.curveCount; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
        count = 0;
        for (j = _k = 0; _k < 32; j = ++_k) {
          if (tag & (1 << j)) {
            if (count === i) {
              this.data.curve[i] = {
                channelIndex: j
              };
              break;
            }
            count++;
          }
        }
        this.data.curve[i].pointCount = this.file.getShortInt();
        assert(this.data.curve[i].pointCount >= 2);
        assert(this.data.curve[i].pointCount <= 19);
        for (j = _l = 0, _ref1 = this.data.curve[i].pointCount; 0 <= _ref1 ? _l < _ref1 : _l > _ref1; j = 0 <= _ref1 ? ++_l : --_l) {
          this.data.curve[i].outputValue[j] = this.file.readShortInt();
          this.data.curve[i].inputValue[j] = this.file.readShortInt();
          assert(this.data.curve[i].outputValue[j] >= 0);
          assert(this.data.curve[i].outputValue[j] <= 255);
          assert(this.data.curve[i].inputValue[j] >= 0);
          assert(this.data.curve[i].inputValue[j] <= 255);
        }
      }
      if (this.file.tell() - start < this.length - 4) {
        tag = this.file.readString(4);
        assert.equal(tag, 'Crv ');
        version = this.file.readShortInt();
        assert(version === 4);
        curveCount = this.file.readInt();
        assert.equal(curveCount, this.data.curveCount);
        for (i = _m = 0, _ref2 = this.data.curveCount; 0 <= _ref2 ? _m < _ref2 : _m > _ref2; i = 0 <= _ref2 ? ++_m : --_m) {
          this.data.curve[i].channelIndex = this.file.readShortInt();
          pointCount = this.file.readShortInt();
          assert(pointCount === this.data.curve[i].pointCount);
          for (j = _n = 0; 0 <= pointCount ? _n < pointCount : _n > pointCount; j = 0 <= pointCount ? ++_n : --_n) {
            outputValue = this.file.getShortInt();
            inputValue = this.file.getShortInt();
            assert.equal(outputValue, this.data.curve[i].outputValue[j]);
            assert.equal(inputValue, this.data.curve[i].inputValue[j]);
          }
        }
      }
      return this.data;
    };

    return PSDCurves;

  })();

  PSDExposure = (function() {

    function PSDExposure(layer, length) {
      this.layer = layer;
      this.length = length;
      this.file = this.layer.file;
    }

    PSDExposure.prototype.parse = function() {
      var version;
      version = this.file.parseInt();
      assert(version === 1);
      return {
        exposure: this.file.parseInt(),
        offset: this.file.parseInt(),
        gamma: this.file.parseInt()
      };
    };

    return PSDExposure;

  })();

  PSDGradient = (function() {

    function PSDGradient(layer, length) {
      this.layer = layer;
      this.length = length;
      this.file = this.layer.file;
    }

    PSDGradient.prototype.parse = function() {
      var descriptor, gradient, version;
      version = this.file.readInt();
      assert(version === 16);
      descriptor = (new PSDDescriptor(this.file)).parse();
      gradient = Parser.parseGradient(descriptor);
      return gradient;
    };

    return PSDGradient;

  })();

  PSDHueSaturation = (function() {

    function PSDHueSaturation(layer, length) {
      this.layer = layer;
      this.length = length;
      this.file = this.layer.file;
    }

    PSDHueSaturation.prototype.parse = function() {
      var i, j, version, _i, _j, _k;
      version = this.file.getShortInt();
      assert(version === 2);
      this.data.colorization = this.file.readBoolean();
      this.file.seek(1);
      this.data.hue = this.file.getShortInt();
      this.data.saturation = this.file.getShortInt();
      this.data.lightness = this.file.getShortInt();
      this.data.masterHue = this.file.getShortInt();
      this.data.masterSaturation = this.file.getShortInt();
      this.data.masterLightness = this.file.getShortInt();
      this.data.rangeValues = [];
      this.data.settingValues = [];
      for (i = _i = 0; _i < 6; i = ++_i) {
        this.data.rangeValues[i] = [];
        this.data.settingValues[i] = [];
        for (j = _j = 0; _j < 4; j = ++_j) {
          this.data.rangeValues[i][j] = this.file.getShortInt();
        }
        for (j = _k = 0; _k < 3; j = ++_k) {
          this.data.settingValues[i][j] = this.file.getShortInt();
        }
      }
      return this.data;
    };

    return PSDHueSaturation;

  })();

  PSDInvert = (function() {

    function PSDInvert(layer, length) {
      this.layer = layer;
      this.length = length;
      this.file = this.layer.file;
    }

    PSDInvert.prototype.parse = function() {
      return true;
    };

    return PSDInvert;

  })();

  PSDEffectsInfo = (function() {

    function PSDEffectsInfo(layer, length) {
      this.layer = layer;
      this.length = length;
      this.file = this.layer.file;
    }

    PSDEffectsInfo.prototype.parse = function() {
      var descriptor, effects, effectsVersion, version;
      effectsVersion = this.file.readInt();
      assert(effectsVersion === 0);
      version = this.file.readInt();
      assert(version === 16);
      descriptor = (new PSDEffectsDescriptor(this.file)).parse();
      effects = Parser.parseEffects(descriptor);
      return effects;
    };

    PSDEffectsInfo.prototype.parseLegacy = function() {
      var count, data, effect, effects, left, pos, signature, size, type, v, _ref, _ref1;
      effects = [];
      _ref = this.file.readf(">HH"), v = _ref[0], count = _ref[1];
      while (count-- > 0) {
        _ref1 = this.file.readf(">4s4s"), signature = _ref1[0], type = _ref1[1];
        size = this.file.readf(">i")[0];
        pos = this.file.tell();
        Log.debug("Parsing effect layer with type " + type + " and size " + size);
        effect = (function() {
          switch (type) {
            case "cmnS":
              return new PSDLayerEffectCommonStateInfo(this.file);
            case "dsdw":
              return new PSDDropDownLayerEffect(this.file);
            case "isdw":
              return new PSDDropDownLayerEffect(this.file, true);
          }
        }).call(this);
        data = effect != null ? effect.parse() : void 0;
        left = (pos + size) - this.file.tell();
        if (left !== 0) {
          Log.debug("Failed to parse effect layer with type " + type);
          this.file.seek(left);
        } else {
          if (type !== "cmnS") {
            effects.push(data);
          }
        }
      }
      return {
        legacy: true,
        effects: effects
      };
    };

    return PSDEffectsInfo;

  })();

  PSDEffectsDescriptor = (function(_super) {

    __extends(PSDEffectsDescriptor, _super);

    function PSDEffectsDescriptor() {
      return PSDEffectsDescriptor.__super__.constructor.apply(this, arguments);
    }

    PSDEffectsDescriptor.prototype.parseItem = function(id) {
      var data, type;
      type = this.file.readString(4);
      data = PSDEffectsDescriptor.__super__.parseItem.call(this, id, type);
      return data;
    };

    return PSDEffectsDescriptor;

  })(PSDDescriptor);

  PSDLayerEffect = (function() {

    function PSDLayerEffect(file) {
      this.file = file;
    }

    PSDLayerEffect.prototype.parse = function() {
      var _ref;
      return _ref = this.file.readf(">i"), this.version = _ref[0], _ref;
    };

    PSDLayerEffect.prototype.getSpaceColor = function() {
      this.file.read(2);
      return this.file.readf(">HHHH");
    };

    return PSDLayerEffect;

  })();

  PSDLayerEffectCommonStateInfo = (function(_super) {

    __extends(PSDLayerEffectCommonStateInfo, _super);

    function PSDLayerEffectCommonStateInfo() {
      return PSDLayerEffectCommonStateInfo.__super__.constructor.apply(this, arguments);
    }

    PSDLayerEffectCommonStateInfo.prototype.parse = function() {
      PSDLayerEffectCommonStateInfo.__super__.parse.call(this);
      this.visible = this.file.readBoolean();
      this.file.read(2);
      return {
        visible: this.visible
      };
    };

    return PSDLayerEffectCommonStateInfo;

  })(PSDLayerEffect);

  PSDDropDownLayerEffect = (function(_super) {

    __extends(PSDDropDownLayerEffect, _super);

    function PSDDropDownLayerEffect(file, inner) {
      this.inner = inner != null ? inner : false;
      PSDDropDownLayerEffect.__super__.constructor.call(this, file);
      this.blendMode = "mul";
      this.color = this.nativeColor = [0, 0, 0, 0];
      this.opacity = 191;
      this.angle = 120;
      this.useGlobalLight = true;
      this.distance = 5;
      this.spread = 0;
      this.size = 5;
      this.antiAliased = false;
      this.knocksOut = false;
    }

    PSDDropDownLayerEffect.prototype.parse = function() {
      var data, key, val, _ref, _ref1;
      PSDDropDownLayerEffect.__super__.parse.call(this);
      _ref = this.file.readf(">hiii"), this.blur = _ref[0], this.intensity = _ref[1], this.angle = _ref[2], this.distance = _ref[3];
      this.file.read(2);
      this.color = this.getSpaceColor();
      _ref1 = this.file.readf(">4s4s"), this.signature = _ref1[0], this.blendMode = _ref1[1];
      this.enabled = this.file.readBoolean();
      this.useAngleInAllFX = this.file.readBoolean();
      this.opacity = this.file.read(1)[0];
      if (this.version === 2) {
        this.nativeColor = this.getSpaceColor();
      }
      data = {};
      for (key in this) {
        if (!__hasProp.call(this, key)) continue;
        val = this[key];
        if (key === "file") {
          continue;
        }
        data[key] = val;
      }
      return data;
    };

    return PSDDropDownLayerEffect;

  })(PSDLayerEffect);

  PSDLevels = (function() {

    function PSDLevels(layer, length) {
      this.layer = layer;
      this.length = length;
      this.file = this.layer.file;
      this.data = {
        records: []
      };
    }

    PSDLevels.prototype.parse = function() {
      var start, tag, version;
      start = this.file.tell();
      version = this.file.readShortInt();
      assert(version === 1);
      this.parseLevelRecords();
      if (this.file.tell() - start < this.length - 4) {
        tag = this.file.readf(">4s");
        assert.equal(tag, "Lvls");
        version = this.file.readShortInt();
        assert.equal(version, 3);
        this.data.levelCount = this.file.readShortInt() - 29;
        assert(levelCount >= 0);
        this.parseLevelRecords(levelCount);
        return this.data;
      }
    };

    PSDLevels.prototype.parseLevelRecords = function(count) {
      var i, record, _i, _ref, _results;
      if (count == null) {
        count = 29;
      }
      _results = [];
      for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
        record = {};
        _ref = this.file.readf(">hhhhh"), record.inputFloor = _ref[0], record.inputCeiling = _ref[1], record.outputFloor = _ref[2], record.outputCeiling = _ref[3], record.gamma = _ref[4];
        record.gamma /= 100;
        if (i < 27) {
          assert(record.inputFloor >= 0 && record.inputFloor <= 255);
          assert(record.inputCeiling >= 2 && record.inputCeiling <= 255);
          assert(record.outputFloor >= 0 && record.outputFloor <= 255);
          assert(record.outputCeiling >= 0 && record.outputCeiling <= 255);
          assert(record.gamma >= 0.1 && record.gamma <= 9.99);
        }
        _results.push(this.data.records.push(record));
      }
      return _results;
    };

    return PSDLevels;

  })();

  PSDPattern = (function() {

    function PSDPattern(layer, length) {
      this.layer = layer;
      this.length = length;
      this.file = this.layer.file;
    }

    PSDPattern.prototype.parse = function() {
      var descriptor, version;
      version = this.file.readInt();
      assert(version === 16);
      descriptor = (new PSDDescriptor(this.file)).parse();
      return Parser.parsePattern(descriptor);
    };

    return PSDPattern;

  })();

  PSDPhotoFilter = (function() {

    function PSDPhotoFilter(layer, length) {
      this.layer = layer;
      this.length = length;
      this.file = this.layer.file;
    }

    PSDPhotoFilter.prototype.parse = function() {
      var data, version;
      version = this.file.parseInt();
      assert(version === 3);
      data = {};
      data.color = {
        x: this.file.readInt(),
        y: this.file.readInt(),
        z: this.file.readInt()
      };
      data.density = this.file.readInt();
      data.preserveLuminosity = this.file.readBoolean();
      return data;
    };

    return PSDPhotoFilter;

  })();

  PSDPosterize = (function() {

    function PSDPosterize(layer, length) {
      this.layer = layer;
      this.length = length;
      this.file = this.layer.file;
      this.data = {};
    }

    PSDPosterize.prototype.parse = function() {
      this.data.levels = this.file.readShortInt();
      assert(this.data.levels >= 2 && this.data.levels <= 255);
      this.file.seek(2);
      return this.data;
    };

    return PSDPosterize;

  })();

  PSDSelectiveColor = (function() {

    function PSDSelectiveColor(layer, length) {
      this.layer = layer;
      this.length = length;
      this.file = this.layer.file;
      this.data = {
        cyanCorrection: [],
        magentaCorrection: [],
        yellowCorrection: [],
        blackCorrection: []
      };
    }

    PSDSelectiveColor.prototype.parse = function() {
      var i, version, _i;
      version = this.file.getShortInt();
      assert(version === 1);
      this.data.correctionMethod = this.file.getShortInt();
      for (i = _i = 0; _i < 10; i = ++_i) {
        this.data.cyanCorrection.push(this.file.getShortInt());
        this.data.magentaCorrection.push(this.file.getShortInt());
        this.data.yellowCorrection.push(this.file.getShortInt());
        this.data.blackCorrection.push(this.file.getShortInt());
      }
      return this.data;
    };

    return PSDSelectiveColor;

  })();

  PSDSolidColor = (function() {

    function PSDSolidColor(layer, length) {
      this.layer = layer;
      this.length = length;
      this.file = this.layer.file;
    }

    PSDSolidColor.prototype.parse = function() {
      var descriptor, fill_color, version;
      version = this.file.readInt();
      assert(version === 16);
      descriptor = (new PSDDescriptor(this.file)).parse();
      fill_color = Parser.parseColor(descriptor.color);
      return {
        "color": fill_color
      };
    };

    return PSDSolidColor;

  })();

  PSDThreshold = (function() {

    function PSDThreshold(layer, length) {
      this.layer = layer;
      this.length = length;
      this.file = this.layer.file;
      this.data = {};
    }

    PSDThreshold.prototype.parse = function() {
      this.data.level = this.file.readShortInt();
      assert(this.data.level >= 1 && this.data.level <= 255);
      this.file.seek(2);
      return this.data;
    };

    return PSDThreshold;

  })();

  PSDTypeTool = (function() {

    PSDTypeTool.prototype.engineDataRegex = [
      {
        search: /\u0000/g,
        replace: ""
      }, {
        search: /<</g,
        replace: ' {'
      }, {
        search: />>/g,
        replace: '},'
      }, {
        search: /\(([^\)]*)\n([^\)]*)\)/,
        replace: '($1 $2)'
      }, {
        search: /\(/g,
        replace: '"'
      }, {
        search: /\)/g,
        replace: '"'
      }, {
        search: /\/(\w+)\s+(\{)\s+/g,
        replace: '"$1": $2\n'
      }, {
        search: /\/(\w+)\s+(\[)\s+/g,
        replace: '"$1": $2'
      }, {
        search: /"(\w+)":\s(\[.*\])\s+/g,
        replace: '"$1": "$2",\n'
      }, {
        search: /\/(\w+)\s+([0-9]+\.[0-9]+|[0-9]+)\s+/g,
        replace: '"$1": $2,\n'
      }, {
        search: /\/(\w+)\s+([0-9]+)\s+/g,
        replace: '"$1": $2,\n'
      }, {
        search: /\/(\w+)\s+(.*)\s/g,
        replace: '"$1": $2,\n'
      }, {
        search: /\]/g,
        replace: '],'
      }, {
        search: /\,([\t\r\n]*)\}/g,
        replace: '$1}'
      }, {
        search: /\,([\t\r\n]*)\]/g,
        replace: '$1]'
      }, {
        search: /\(\u00FE\u00FF(.*)\)/g,
        replace: '"$1"'
      }
    ];

    function PSDTypeTool(layer, length) {
      this.layer = layer;
      this.length = length;
      this.file = this.layer.file;
      this.data = {};
    }

    PSDTypeTool.prototype.parse = function(legacy) {
      var char, descriptorVersion, engineData, regex, textVersion, version, warpVersion, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
      if (legacy == null) {
        legacy = false;
      }
      version = this.file.readShortInt();
      assert(version === 1);
      this.data.transformInfo = {};
      _ref = this.file.readf(">6d"), this.data.transformInfo.xx = _ref[0], this.data.transformInfo.xy = _ref[1], this.data.transformInfo.yx = _ref[2], this.data.transformInfo.yy = _ref[3], this.data.transformInfo.tx = _ref[4], this.data.transformInfo.ty = _ref[5];
      if (legacy) {
        return this.parseLegacy();
      }
      textVersion = this.file.readShortInt();
      assert(textVersion === 50);
      descriptorVersion = this.file.readInt();
      assert(descriptorVersion === 16);
      this.data.text = (new PSDDescriptor(this.file)).parse();
      engineData = "";
      _ref1 = this.data.text.EngineData;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        char = _ref1[_i];
        engineData += String.fromCharCode(char);
      }
      _ref2 = this.engineDataRegex;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        regex = _ref2[_j];
        engineData = engineData.replace(regex.search, regex.replace);
      }
      this.data.text.EngineData = engineData;
      Log.debug("Text:", this.data.text);
      warpVersion = this.file.readShortInt();
      assert(warpVersion === 1);
      descriptorVersion = this.file.readInt();
      assert(descriptorVersion === 16);
      this.data.warp = (new PSDDescriptor(this.file)).parse();
      Log.debug("Warp:", this.data.warp);
      _ref3 = this.file.readf(">4d"), this.data.left = _ref3[0], this.data.top = _ref3[1], this.data.right = _ref3[2], this.data.bottom = _ref3[3];
      return this.data;
    };

    PSDTypeTool.prototype.parseLegacy = function() {
      var i, j, version, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
      version = this.file.readShortInt();
      assert(version === 6);
      this.data.facesCount = this.file.readShortInt();
      this.data.face = [];
      for (i = _i = 0, _ref = this.data.facesCount; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.data.face[i] = {};
        this.data.face[i].mark = this.file.readShortInt();
        this.data.face[i].fontType = this.file.readInt();
        this.data.face[i].fontName = this.file.readLengthWithString();
        this.data.face[i].fontFamilyName = this.file.readLengthWithString();
        this.data.face[i].fontStyleName = this.file.readLengthWithString();
        this.data.face[i].script = this.file.readShortInt();
        this.data.face[i].numberAxesVector = this.file.readInt();
        this.data.face[i].vector = [];
        for (j = _j = 0, _ref1 = this.data.face[i].numberAxesVector; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          this.data.face[i].vector[j] = this.file.readInt();
        }
      }
      this.data.stylesCount = this.file.readShortInt();
      this.data.style = [];
      for (i = _k = 0, _ref2 = this.data.stylesCount; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        this.data.style[i] = {};
        this.data.style[i].mark = this.file.readShortInt();
        this.data.style[i].faceMark = this.file.readShortInt();
        this.data.style[i].size = this.file.readInt();
        this.data.style[i].tracking = this.file.readInt();
        this.data.style[i].kerning = this.file.readInt();
        this.data.style[i].leading = this.file.readInt();
        this.data.style[i].baseShift = this.file.readInt();
        this.data.style[i].autoKern = this.file.readBoolean();
        this.file.read(1);
        this.data.style[i].rotate = this.file.readBoolean();
      }
      this.data.type = this.file.readShortInt();
      this.data.scalingFactor = this.file.readInt();
      this.data.sharacterCount = this.file.readInt();
      this.data.horzPlace = this.file.readInt();
      this.data.vertPlace = this.file.readInt();
      this.data.selectStart = this.file.readInt();
      this.data.selectEnd = this.file.readInt();
      this.data.linesCount = this.file.readShortInt();
      this.data.line = [];
      for (i = _l = 0, _ref3 = this.data.linesCount; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; i = 0 <= _ref3 ? ++_l : --_l) {
        this.data.line[i].charCount = this.file.readInt();
        this.data.line[i].orientation = this.file.readShortInt();
        this.data.line[i].alignment = this.file.readShortInt();
        this.data.line[i].actualChar = this.file.readShortInt();
        this.data.line[i].style = this.file.readShortInt();
      }
      this.data.color = this.file.readSpaceColor();
      this.data.antialias = this.file.readBoolean();
      return this.data;
    };

    return PSDTypeTool;

  })();

  PSDVibrance = (function() {

    function PSDVibrance(layer, length) {
      this.layer = layer;
      this.length = length;
      this.file = this.layer.file;
    }

    PSDVibrance.prototype.parse = function() {
      var version;
      version = this.file.readInt();
      assert(version === 16);
      return (new PSDDescriptor(this.file)).parse();
    };

    return PSDVibrance;

  })();

  PSDResource = (function() {
    var RESOURCE_DESCRIPTIONS;

    RESOURCE_DESCRIPTIONS = {
      1000: {
        name: 'PS2.0 mode data',
        parse: function() {
          var _ref;
          return _ref = this.file.readf(">5H"), this.channels = _ref[0], this.rows = _ref[1], this.cols = _ref[2], this.depth = _ref[3], this.mode = _ref[4], _ref;
        }
      },
      1001: {
        name: 'Macintosh print record'
      },
      1003: {
        name: 'PS2.0 indexed color table'
      },
      1005: {
        name: 'ResolutionInfo'
      },
      1006: {
        name: 'Names of the alpha channels'
      },
      1007: {
        name: 'DisplayInfo'
      },
      1008: {
        name: 'Caption',
        parse: function() {
          return this.caption = this.file.readLengthWithString();
        }
      },
      1009: {
        name: 'Border information',
        parse: function() {
          var units, _ref;
          _ref = this.file.readf(">fH"), this.width = _ref[0], units = _ref[1];
          return this.units = (function() {
            switch (units) {
              case 1:
                return "inches";
              case 2:
                return "cm";
              case 3:
                return "points";
              case 4:
                return "picas";
              case 5:
                return "columns";
            }
          })();
        }
      },
      1010: {
        name: 'Background color'
      },
      1011: {
        name: 'Print flags',
        parse: function() {
          var start, _ref;
          start = this.file.tell();
          _ref = this.file.readf(">9B"), this.labels = _ref[0], this.cropMarks = _ref[1], this.colorBars = _ref[2], this.registrationMarks = _ref[3], this.negative = _ref[4], this.flip = _ref[5], this.interpolate = _ref[6], this.caption = _ref[7];
          return this.file.seek(start + this.size, false);
        }
      },
      1012: {
        name: 'Grayscale/multichannel halftoning info'
      },
      1013: {
        name: 'Color halftoning info'
      },
      1014: {
        name: 'Duotone halftoning info'
      },
      1015: {
        name: 'Grayscale/multichannel transfer function'
      },
      1016: {
        name: 'Color transfer functions'
      },
      1017: {
        name: 'Duotone transfer functions'
      },
      1018: {
        name: 'Duotone image info'
      },
      1019: {
        name: 'B&W values for the dot range',
        parse: function() {
          var _ref;
          return _ref = this.file.readf(">H"), this.bwvalues = _ref[0], _ref;
        }
      },
      1021: {
        name: 'EPS options'
      },
      1022: {
        name: 'Quick Mask info',
        parse: function() {
          var _ref;
          return _ref = this.file.readf(">HB"), this.quickMaskChannelID = _ref[0], this.wasMaskEmpty = _ref[1], _ref;
        }
      },
      1024: {
        name: 'Layer state info',
        parse: function() {
          var _ref;
          return _ref = this.file.readf(">H"), this.targetLayer = _ref[0], _ref;
        }
      },
      1025: {
        name: 'Working path'
      },
      1026: {
        name: 'Layers group info',
        parse: function() {
          var info, start, _results;
          start = this.file.tell();
          this.layerGroupInfo = [];
          _results = [];
          while (this.file.tell() < start + this.size) {
            info = this.file.readf(">H")[0];
            _results.push(this.layerGroupInfo.push(info));
          }
          return _results;
        }
      },
      1028: {
        name: 'IPTC-NAA record (File Info)'
      },
      1029: {
        name: 'Image mode for raw format files'
      },
      1030: {
        name: 'JPEG quality'
      },
      1032: {
        name: 'Grid and guides info'
      },
      1033: {
        name: 'Thumbnail resource'
      },
      1034: {
        name: 'Copyright flag',
        parse: function() {
          var _ref;
          return _ref = this.file.readf(">" + this.size + "B"), this.copyrighted = _ref[0], _ref;
        }
      },
      1035: {
        name: 'URL',
        parse: function() {
          var _ref;
          return _ref = this.file.readf(">" + this.size + "s"), this.url = _ref[0], _ref;
        }
      },
      1036: {
        name: 'Thumbnail resource'
      },
      1037: {
        name: 'Global Angle'
      },
      1038: {
        name: 'Color samplers resource'
      },
      1039: {
        name: 'ICC Profile'
      },
      1040: {
        name: 'Watermark',
        parse: function() {
          var _ref;
          return _ref = this.file.readf(">B"), this.watermarked = _ref[0], _ref;
        }
      },
      1041: {
        name: 'ICC Untagged'
      },
      1042: {
        name: 'Effects visible',
        parse: function() {
          var _ref;
          return _ref = this.file.readf(">B"), this.showEffects = _ref[0], _ref;
        }
      },
      1043: {
        name: 'Spot Halftone',
        parse: function() {
          [this.halftoneVersion, length](this.file.readf(">LL"));
          return this.halftoneData = this.file.read(length);
        }
      },
      1044: {
        name: 'Document specific IDs seed number',
        parse: function() {
          var _ref;
          return _ref = this.file.readf(">L"), this.docIdSeedNumber = _ref[0], _ref;
        }
      },
      1045: {
        name: 'Unicode Alpha Names'
      },
      1046: {
        name: 'Indexed Color Table Count',
        parse: function() {
          var _ref;
          return _ref = this.file.readf(">H"), this.indexedColorCount = _ref[0], _ref;
        }
      },
      1047: {
        name: 'Transparent Index',
        parse: function() {
          var _ref;
          return _ref = this.file.readf(">H"), this.transparencyIndex = _ref[0], _ref;
        }
      },
      1049: {
        name: 'Global Altitude',
        parse: function() {
          var _ref;
          return _ref = this.file.readf(">L"), this.globalAltitude = _ref[0], _ref;
        }
      },
      1050: {
        name: 'Slices'
      },
      1051: {
        name: 'Workflow URL',
        parse: function() {
          return this.workflowName = this.file.readLengthWithString();
        }
      },
      1052: {
        name: 'Jump To XPEP',
        parse: function() {
          var block, count, i, _i, _ref, _results;
          _ref = this.file.readf(">HHL"), this.majorVersion = _ref[0], this.minorVersion = _ref[1], count = _ref[2];
          this.xpepBlocks = [];
          _results = [];
          for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
            block = {
              size: this.file.readf(">L"),
              key: this.file.readf(">4s")
            };
            if (block.key === "jtDd") {
              block.dirty = this.file.readBoolean();
            } else {
              block.modDate = this.file.readf(">L");
            }
            _results.push(this.xpepBlocks.push(block));
          }
          return _results;
        }
      },
      1053: {
        name: 'Alpha Identifiers'
      },
      1054: {
        name: 'URL List'
      },
      1057: {
        name: 'Version Info'
      },
      1058: {
        name: 'EXIF data 1'
      },
      1059: {
        name: 'EXIF data 3'
      },
      1060: {
        name: 'XMP metadata'
      },
      1061: {
        name: 'Caption digest'
      },
      1062: {
        name: 'Print scale'
      },
      1064: {
        name: 'Pixel Aspect Ratio'
      },
      1065: {
        name: 'Layer Comps'
      },
      1066: {
        name: 'Alternate Duotone Colors'
      },
      1067: {
        name: 'Alternate Spot Colors'
      },
      1069: {
        name: 'Layer Selection ID(s)'
      },
      1070: {
        name: 'HDR Toning information'
      },
      1071: {
        name: "Print info"
      },
      1072: {
        name: "Layer Groups Enabled"
      },
      1073: {
        name: "Color samplers resource"
      },
      1074: {
        name: "Measurement Scale"
      },
      1075: {
        name: "Timeline Information"
      },
      1076: {
        name: "Sheet Disclosure"
      },
      1077: {
        name: "DisplayInfo"
      },
      1078: {
        name: "Onion Skins"
      },
      1080: {
        name: "Count Information"
      },
      1082: {
        name: "Print Information"
      },
      1083: {
        name: "Print Style"
      },
      1084: {
        name: "Macintosh NSPrintInfo"
      },
      1085: {
        name: "Windows DEVMODE"
      },
      2999: {
        name: 'Name of clipping path'
      },
      7000: {
        name: "Image Ready variables"
      },
      7001: {
        name: "Image Ready data sets"
      },
      8000: {
        name: "Lightroom workflow",
        parse: PSDResource.isLightroom = true
      },
      10000: {
        name: 'Print flags info',
        parse: function() {
          var padding, _ref;
          return _ref = this.file.readf(">HBBLH"), this.version = _ref[0], this.centerCropMarks = _ref[1], padding = _ref[2], this.bleedWidth = _ref[3], this.bleedWidthScale = _ref[4], _ref;
        }
      }
    };

    function PSDResource(file) {
      this.file = file;
    }

    PSDResource.prototype.parse = function() {
      var n, resource, _ref, _ref1, _ref2;
      this.at = this.file.tell();
      _ref = this.file.readf(">4s H B"), this.type = _ref[0], this.id = _ref[1], this.namelen = _ref[2];
      Log.debug("Resource #" + this.id + ": type=" + this.type);
      n = Util.pad2(this.namelen + 1) - 1;
      this.name = this.file.readf(">" + n + "s")[0];
      this.name = this.name.substr(0, this.name.length - 1);
      this.shortName = this.name.substr(0, 20);
      this.size = this.file.readInt();
      this.size = Util.pad2(this.size);
      if ((2000 <= (_ref1 = this.id) && _ref1 <= 2998)) {
        this.rdesc = "[Path Information]";
        return this.file.seek(this.size);
      } else if (this.id === 2999) {
        return assert(0);
      } else if ((4000 <= (_ref2 = this.id) && _ref2 < 5000)) {
        this.rdesc = "[Plug-in Resource]";
        return this.file.seek(this.size);
      } else if (RESOURCE_DESCRIPTIONS[this.id] != null) {
        resource = RESOURCE_DESCRIPTIONS[this.id];
        this.rdesc = "[" + resource.name + "]";
        if (resource.parse != null) {
          return resource.parse.call(this);
        } else {
          return this.file.seek(this.size);
        }
      } else {
        return this.file.seek(this.size);
      }
    };

    PSDResource.prototype.toJSON = function() {
      var data, section, sections, _i, _len;
      sections = ['type', 'id', 'name', 'rdesc'];
      data = {};
      for (_i = 0, _len = sections.length; _i < _len; _i++) {
        section = sections[_i];
        data[section] = this[section];
      }
      return data;
    };

    return PSDResource;

  })();

  Util = (function() {

    function Util() {}

    Util.pad2 = function(i) {
      return Math.floor((i + 1) / 2) * 2;
    };

    Util.pad4 = function(i) {
      return i - (i % 4) + 3;
    };

    Util.toUInt16 = function(b1, b2) {
      return (b1 << 8) | b2;
    };

    Util.toInt16 = function(b1, b2) {
      var val;
      val = this.toUInt16(b1, b2);
      if (val >= 0x8000) {
        return val - 0x10000;
      } else {
        return val;
      }
    };

    Util.round = function(num, sigFig) {
      var mult;
      if (sigFig == null) {
        sigFig = 2;
      }
      if (sigFig === 0) {
        return Math.round(num);
      }
      mult = Math.pow(10, sigFig);
      return Math.round(num * mult) / mult;
    };

    Util.clamp = function(num, min, max) {
      var i, val, _i, _len;
      if (min == null) {
        min = Number.MIN_VALUE;
      }
      if (max == null) {
        max = Number.MAX_VALUE;
      }
      if (typeof num === "object" && (num.length != null)) {
        for (i = _i = 0, _len = num.length; _i < _len; i = ++_i) {
          val = num[i];
          num[i] = Math.max(Math.min(val, max), min);
        }
      } else if (typeof num === "object") {
        for (i in num) {
          if (!__hasProp.call(num, i)) continue;
          val = num[i];
          num[i] = Math.max(Math.min(val, max), min);
        }
      } else {
        num = Math.max(Math.min(num, max), min);
      }
      return num;
    };

    Util.decodeMacroman = (function() {
      var high_chars_unicode;
      high_chars_unicode = '\u00c4\u00c5\u00c7\u00c9\u00d1\u00d6\u00dc\u00e1\n\u00e0\u00e2\u00e4\u00e3\u00e5\u00e7\u00e9\u00e8\n\u00ea\u00eb\u00ed\u00ec\u00ee\u00ef\u00f1\u00f3\n\u00f2\u00f4\u00f6\u00f5\u00fa\u00f9\u00fb\u00fc\n\u2020\u00b0\u00a2\u00a3\u00a7\u2022\u00b6\u00df\n\u00ae\u00a9\u2122\u00b4\u00a8\u2260\u00c6\u00d8\n\u221e\u00b1\u2264\u2265\u00a5\u00b5\u2202\u2211\n\u220f\u03c0\u222b\u00aa\u00ba\u03a9\u00e6\u00f8\n\u00bf\u00a1\u00ac\u221a\u0192\u2248\u2206\u00ab\n\u00bb\u2026\u00a0\u00c0\u00c3\u00d5\u0152\u0153\n\u2013\u2014\u201c\u201d\u2018\u2019\u00f7\u25ca\n\u00ff\u0178\u2044\u20ac\u2039\u203a\ufb01\ufb02\n\u2021\u00b7\u201a\u201e\u2030\u00c2\u00ca\u00c1\n\u00cb\u00c8\u00cd\u00ce\u00cf\u00cc\u00d3\u00d4\n\uf8ff\u00d2\u00da\u00db\u00d9\u0131\u02c6\u02dc\n\u00af\u02d8\u02d9\u02da\u00b8\u02dd\u02db\u02c7'.replace(/\n/g, '');
      return function(byte_array) {
        var byte, char_array, idx;
        char_array = (function() {
          var _i, _len, _results;
          _results = [];
          for (idx = _i = 0, _len = byte_array.length; _i < _len; idx = ++_i) {
            byte = byte_array[idx];
            if (byte < 0x80) {
              _results.push(String.fromCharCode(byte));
            } else {
              _results.push(high_chars_unicode.charAt(byte - 0x80));
            }
          }
          return _results;
        })();
        return char_array.join('');
      };
    })();

    return Util;

  })();

  Log = (function() {

    function Log() {}

    Log.debug = Log.log = function() {
      return this.output("log", arguments);
    };

    Log.output = function(method, data) {
      if (typeof exports !== "undefined" && exports !== null) {
        if (PSD.DEBUG) {
          return console[method].apply(null, data);
        }
      } else {
        if (PSD.DEBUG) {
          return console[method]("[PSD]", data);
        }
      }
    };

    return Log;

  })();

}).call(this);
